'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));
var merge = _interopDefault(require('lodash/merge'));
var get = _interopDefault(require('lodash/get'));
var set = _interopDefault(require('lodash/set'));
var isFunction = _interopDefault(require('lodash/isFunction'));
var d3Format = require('d3-format');
var Measure = _interopDefault(require('react-measure'));
var pure = _interopDefault(require('recompose/pure'));
var reactMotion = require('react-motion');
var d3Interpolate = require('d3-interpolate');
var d3TimeFormat = require('d3-time-format');
var compose = _interopDefault(require('recompose/compose'));
var withPropsOnChange = _interopDefault(require('recompose/withPropsOnChange'));
var setPropTypes = _interopDefault(require('recompose/setPropTypes'));
var defaultProps = _interopDefault(require('recompose/defaultProps'));
var last = _interopDefault(require('lodash/last'));
var isArray = _interopDefault(require('lodash/isArray'));
var isString = _interopDefault(require('lodash/isString'));
var d3Scale = require('d3-scale');
var d3ScaleChromatic = require('d3-scale-chromatic');
var memoize = _interopDefault(require('lodash/memoize'));
var d3Color = require('d3-color');
var withProps = _interopDefault(require('recompose/withProps'));
var without = _interopDefault(require('lodash/without'));
var d3Shape = require('d3-shape');
var d3Hierarchy = require('d3-hierarchy');
var isEqual = _interopDefault(require('lodash/isEqual'));
var partialRight = _interopDefault(require('lodash/partialRight'));
var isNumber = _interopDefault(require('lodash/isNumber'));
var shouldUpdate = _interopDefault(require('recompose/shouldUpdate'));
var isPlainObject = _interopDefault(require('lodash/isPlainObject'));
var pick = _interopDefault(require('lodash/pick'));

var noop = (function () {});

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var textProps = {
  fill: PropTypes.string,
  fontSize: PropTypes.number,
  fontFamily: PropTypes.string
};
var axisThemePropType = PropTypes.shape({
  domain: PropTypes.shape({
    line: PropTypes.shape({
      stroke: PropTypes.string.isRequired,
      strokeWidth: PropTypes.number.isRequired,
      strokeDasharray: PropTypes.string
    }).isRequired
  }).isRequired,
  ticks: PropTypes.shape({
    line: PropTypes.shape({
      stroke: PropTypes.string.isRequired,
      strokeWidth: PropTypes.number.isRequired,
      strokeDasharray: PropTypes.string
    }).isRequired,
    text: PropTypes.shape(_objectSpread({}, textProps)).isRequired
  }).isRequired,
  legend: PropTypes.shape({
    text: PropTypes.shape(_objectSpread({}, textProps)).isRequired
  }).isRequired
});
var gridThemePropType = PropTypes.shape({
  line: PropTypes.shape({
    stroke: PropTypes.string.isRequired,
    strokeWidth: PropTypes.number.isRequired,
    strokeDasharray: PropTypes.string
  }).isRequired
});
var legendsThemePropType = PropTypes.shape({
  text: PropTypes.shape(_objectSpread({}, textProps)).isRequired
});
var labelsThemePropType = PropTypes.shape({
  text: PropTypes.shape(_objectSpread({}, textProps)).isRequired
});
var dotsThemePropType = PropTypes.shape({
  text: PropTypes.shape(_objectSpread({}, textProps)).isRequired
});
var markersThemePropType = PropTypes.shape({
  text: PropTypes.shape(_objectSpread({}, textProps)).isRequired
});
var themePropType = PropTypes.shape({
  background: PropTypes.string.isRequired,
  fontFamily: PropTypes.string.isRequired,
  fontSize: PropTypes.number.isRequired,
  textColor: PropTypes.string.isRequired,
  axis: axisThemePropType.isRequired,
  grid: gridThemePropType.isRequired,
  legends: legendsThemePropType.isRequired,
  labels: labelsThemePropType.isRequired,
  dots: dotsThemePropType.isRequired,
  markers: markersThemePropType
});

var defaultTheme = {
  background: 'transparent',
  fontFamily: 'sans-serif',
  fontSize: 11,
  textColor: '#333333',
  axis: {
    domain: {
      line: {
        stroke: 'transparent',
        strokeWidth: 1
      }
    },
    ticks: {
      line: {
        stroke: '#777777',
        strokeWidth: 1
      },
      text: {}
    },
    legend: {
      text: {}
    }
  },
  grid: {
    line: {
      stroke: '#dddddd',
      strokeWidth: 1
    }
  },
  legends: {
    text: {}
  },
  labels: {
    text: {}
  },
  markers: {
    lineColor: '#000000',
    lineStrokeWidth: 1,
    text: {}
  },
  dots: {
    text: {}
  },
  tooltip: {
    container: {
      background: 'white',
      color: 'inherit',
      fontSize: 'inherit',
      borderRadius: '2px',
      boxShadow: '0 1px 2px rgba(0, 0, 0, 0.25)',
      padding: '5px 9px'
    },
    basic: {
      whiteSpace: 'pre',
      display: 'flex',
      alignItems: 'center'
    },
    table: {},
    tableCell: {
      padding: '3px 5px'
    }
  }
};

var fontProps = ['axis.ticks.text', 'axis.legend.text', 'legends.text', 'labels.text', 'dots.text', 'markers.text'];
var extendDefaultTheme = function extendDefaultTheme(defaultTheme, customTheme) {
  var theme = merge({}, defaultTheme, customTheme);
  fontProps.forEach(function (prop) {
    if (get(theme, "".concat(prop, ".fontFamily")) === undefined) {
      set(theme, "".concat(prop, ".fontFamily"), theme.fontFamily);
    }
    if (get(theme, "".concat(prop, ".fontSize")) === undefined) {
      set(theme, "".concat(prop, ".fontSize"), theme.fontSize);
    }
    if (get(theme, "".concat(prop, ".fill")) === undefined) {
      set(theme, "".concat(prop, ".fill"), theme.textColor);
    }
  });
  return theme;
};

var themeContext = React.createContext();
var useTheme = function useTheme() {
  return React.useContext(themeContext);
};

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } return target; }
function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Chip = React.memo(function (_ref) {
  var size = _ref.size,
      color = _ref.color,
      style = _ref.style;
  return React__default.createElement("span", {
    style: _objectSpread$1({
      display: 'block',
      width: size,
      height: size,
      background: color
    }, style)
  });
});
Chip.propTypes = {
  size: PropTypes.number.isRequired,
  color: PropTypes.string.isRequired,
  style: PropTypes.object.isRequired
};
Chip.defaultProps = {
  size: 12,
  style: {}
};
Chip.displayName = 'Chip';

var chipStyle = {
  marginRight: 7
};
var BasicTooltip = React.memo(function (_ref) {
  var id = _ref.id,
      _value = _ref.value,
      format = _ref.format,
      enableChip = _ref.enableChip,
      color = _ref.color,
      renderContent = _ref.renderContent;
  var theme = useTheme();
  var formatValue = React.useMemo(function () {
    if (!format || isFunction(format)) return format;
    return d3Format.format(format);
  }, [format]);
  var content;
  if (typeof renderContent === 'function') {
    content = renderContent();
  } else {
    var value = _value;
    if (formatValue !== undefined && value !== undefined) {
      value = formatValue(value);
    }
    content = React__default.createElement("div", {
      style: theme.tooltip.basic
    }, enableChip && React__default.createElement(Chip, {
      color: color,
      style: chipStyle
    }), value !== undefined ? React__default.createElement("span", null, id, ": ", React__default.createElement("strong", null, isNaN(value) ? String(value) : value)) : id);
  }
  return React__default.createElement("div", {
    style: theme.tooltip.container
  }, content);
});
BasicTooltip.propTypes = {
  id: PropTypes.node.isRequired,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  enableChip: PropTypes.bool.isRequired,
  color: PropTypes.string,
  format: PropTypes.func,
  renderContent: PropTypes.func
};
BasicTooltip.defaultProps = {
  enableChip: false
};
BasicTooltip.displayName = 'BasicTooltip';

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }
function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var tableStyle = {
  width: '100%',
  borderCollapse: 'collapse'
};
var TableTooltip = React.memo(function (_ref) {
  var title = _ref.title,
      rows = _ref.rows,
      renderContent = _ref.renderContent;
  var theme = useTheme();
  if (!rows.length) return null;
  var content;
  if (typeof renderContent === 'function') {
    content = renderContent();
  } else {
    content = React__default.createElement("div", null, title && title, React__default.createElement("table", {
      style: _objectSpread$2({}, tableStyle, theme.tooltip.table)
    }, React__default.createElement("tbody", null, rows.map(function (row, i) {
      return React__default.createElement("tr", {
        key: i
      }, row.map(function (column, j) {
        return React__default.createElement("td", {
          key: j,
          style: theme.tooltip.tableCell
        }, column);
      }));
    }))));
  }
  return React__default.createElement("div", {
    style: theme.tooltip.container
  }, content);
});
TableTooltip.propTypes = {
  title: PropTypes.node,
  rows: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.node)).isRequired,
  renderContent: PropTypes.func
};
TableTooltip.displayName = 'TableTooltip';

var tooltipContext = React.createContext();
var useTooltip = function useTooltip() {
  return React.useContext(tooltipContext);
};

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } return target; }
function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }
function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var containerStyle = {
  position: 'relative'
};
var tooltipStyle = {
  pointerEvents: 'none',
  position: 'absolute',
  zIndex: 10
};
var Container = function Container(_ref) {
  var children = _ref.children,
      theme = _ref.theme,
      _ref$isInteractive = _ref.isInteractive,
      isInteractive = _ref$isInteractive === void 0 ? true : _ref$isInteractive;
  var containerEl = React.useRef(null);
  var _useState = React.useState({
    isTooltipVisible: false,
    tooltipContent: null,
    position: {}
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];
  var showTooltip = React.useCallback(function (content, event) {
    if (!containerEl) return;
    var bounds = containerEl.current.getBoundingClientRect();
    var clientX = event.clientX,
        clientY = event.clientY;
    var x = clientX - bounds.left;
    var y = clientY - bounds.top;
    var position = {};
    if (x < bounds.width / 2) position.left = x + 20;else position.right = bounds.width - x + 20;
    if (y < bounds.height / 2) position.top = y - 12;else position.bottom = bounds.height - y - 12;
    setState({
      isTooltipVisible: true,
      tooltipContent: content,
      position: position
    });
  }, [containerEl]);
  var hideTooltip = React.useCallback(function () {
    setState({
      isTooltipVisible: false,
      tooltipContent: null
    });
  });
  var isTooltipVisible = state.isTooltipVisible,
      tooltipContent = state.tooltipContent,
      position = state.position;
  var content;
  if (isInteractive) {
    content = React__default.createElement("div", {
      style: containerStyle,
      ref: containerEl
    }, children({
      showTooltip: isInteractive ? showTooltip : noop,
      hideTooltip: isInteractive ? hideTooltip : noop
    }), isTooltipVisible && React__default.createElement("div", {
      style: _objectSpread$3({}, tooltipStyle, position, theme.tooltip)
    }, tooltipContent));
  } else {
    content = children({
      showTooltip: isInteractive ? showTooltip : noop,
      hideTooltip: isInteractive ? hideTooltip : noop
    });
  }
  return React__default.createElement(themeContext.Provider, {
    value: theme
  }, React__default.createElement(tooltipContext.Provider, {
    value: [showTooltip, hideTooltip]
  }, content));
};
Container.propTypes = {
  children: PropTypes.func.isRequired,
  isInteractive: PropTypes.bool.isRequired,
  theme: PropTypes.object.isRequired
};

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var ResponsiveWrapper =
function (_Component) {
  _inherits(ResponsiveWrapper, _Component);
  function ResponsiveWrapper() {
    var _getPrototypeOf2;
    var _this;
    _classCallCheck(this, ResponsiveWrapper);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ResponsiveWrapper)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _defineProperty$4(_assertThisInitialized(_this), "state", {
      dimensions: {
        width: -1,
        height: -1
      }
    });
    return _this;
  }
  _createClass(ResponsiveWrapper, [{
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$state$dimension = this.state.dimensions,
          width = _this$state$dimension.width,
          height = _this$state$dimension.height;
      var shouldRender = width > 0 && height > 0;
      return React__default.createElement(Measure, {
        bounds: true,
        onResize: function onResize(contentRect) {
          _this2.setState({
            dimensions: contentRect.bounds
          });
        }
      }, function (_ref) {
        var measureRef = _ref.measureRef;
        return React__default.createElement("div", {
          ref: measureRef,
          style: {
            width: '100%',
            height: '100%'
          }
        }, shouldRender && _this2.props.children({
          width: width,
          height: height
        }));
      });
    }
  }]);
  return ResponsiveWrapper;
}(React.Component);
_defineProperty$4(ResponsiveWrapper, "propTypes", {
  children: PropTypes.func.isRequired
});

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$5(target, key, source[key]); }); } return target; }
function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var LinearGradient = function LinearGradient(_ref) {
  var id = _ref.id,
      colors = _ref.colors;
  return React__default.createElement("linearGradient", {
    id: id,
    x1: 0,
    x2: 0,
    y1: 0,
    y2: 1
  }, colors.map(function (_ref2) {
    var offset = _ref2.offset,
        color = _ref2.color,
        opacity = _ref2.opacity;
    return React__default.createElement("stop", {
      key: offset,
      offset: "".concat(offset, "%"),
      stopColor: color,
      stopOpacity: opacity !== undefined ? opacity : 1
    });
  }));
};
LinearGradient.propTypes = {
  id: PropTypes.string.isRequired,
  colors: PropTypes.arrayOf(PropTypes.shape({
    offset: PropTypes.number.isRequired,
    color: PropTypes.string.isRequired
  })).isRequired
};
var linearGradientDef = function linearGradientDef(id, colors) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return _objectSpread$4({
    id: id,
    type: 'linearGradient',
    colors: colors
  }, options);
};

var gradientTypes = {
  linearGradient: LinearGradient
};

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$6(target, key, source[key]); }); } return target; }
function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var PatternDots = pure(function (_ref) {
  var id = _ref.id,
      background = _ref.background,
      color = _ref.color,
      size = _ref.size,
      padding = _ref.padding,
      stagger = _ref.stagger;
  var fullSize = size + padding;
  var radius = size / 2;
  var halfPadding = padding / 2;
  if (stagger === true) {
    fullSize = size * 2 + padding * 2;
  }
  return React__default.createElement("pattern", {
    id: id,
    width: fullSize,
    height: fullSize,
    patternUnits: "userSpaceOnUse"
  }, React__default.createElement("rect", {
    width: fullSize,
    height: fullSize,
    fill: background
  }), React__default.createElement("circle", {
    cx: halfPadding + radius,
    cy: halfPadding + radius,
    r: radius,
    fill: color
  }), stagger && React__default.createElement("circle", {
    cx: padding * 1.5 + size + radius,
    cy: padding * 1.5 + size + radius,
    r: radius,
    fill: color
  }));
});
PatternDots.propTypes = {
  id: PropTypes.string.isRequired,
  color: PropTypes.string.isRequired,
  background: PropTypes.string.isRequired,
  size: PropTypes.number.isRequired,
  padding: PropTypes.number.isRequired,
  stagger: PropTypes.bool.isRequired
};
PatternDots.defaultProps = {
  color: '#000000',
  background: '#ffffff',
  size: 4,
  padding: 4,
  stagger: false
};
var patternDotsDef = function patternDotsDef(id) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread$5({
    id: id,
    type: 'patternDots'
  }, options);
};

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }
function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }
function _slicedToArray$1(arr, i) { return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _nonIterableRest$1(); }
function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }
function _iterableToArrayLimit$1(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles$1(arr) { if (Array.isArray(arr)) return arr; }
var TWO_PI = Math.PI * 2;
var degreesToRadians = function degreesToRadians(degrees) {
  return degrees * Math.PI / 180;
};
var radiansToDegrees = function radiansToDegrees(radians) {
  return 180 * radians / Math.PI;
};
var midAngle = function midAngle(arc) {
  return arc.startAngle + (arc.endAngle - arc.startAngle) / 2;
};
var positionFromAngle = function positionFromAngle(angle, distance) {
  return {
    x: Math.cos(angle) * distance,
    y: Math.sin(angle) * distance
  };
};
var absoluteAngleDegrees = function absoluteAngleDegrees(angle) {
  var absAngle = angle % 360;
  if (absAngle < 0) {
    absAngle += 360;
  }
  return absAngle;
};
var absoluteAngleRadians = function absoluteAngleRadians(angle) {
  return angle - TWO_PI * Math.floor((angle + Math.PI) / TWO_PI);
};
var computeArcBoundingBox = function computeArcBoundingBox(ox, oy, radius, startAngle, endAngle) {
  var includeCenter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var points = [];
  var p0 = positionFromAngle(degreesToRadians(startAngle), radius);
  points.push([p0.x, p0.y]);
  var p1 = positionFromAngle(degreesToRadians(endAngle), radius);
  points.push([p1.x, p1.y]);
  for (var angle = Math.round(Math.min(startAngle, endAngle)); angle <= Math.round(Math.max(startAngle, endAngle)); angle++) {
    if (angle % 90 === 0) {
      var p = positionFromAngle(degreesToRadians(angle), radius);
      points.push([p.x, p.y]);
    }
  }
  points = points.map(function (_ref) {
    var _ref2 = _slicedToArray$1(_ref, 2),
        x = _ref2[0],
        y = _ref2[1];
    return [ox + x, oy + y];
  });
  if (includeCenter === true) points.push([ox, oy]);
  var xs = points.map(function (_ref3) {
    var _ref4 = _slicedToArray$1(_ref3, 1),
        x = _ref4[0];
    return x;
  });
  var ys = points.map(function (_ref5) {
    var _ref6 = _slicedToArray$1(_ref5, 2),
        y = _ref6[1];
    return y;
  });
  var x0 = Math.min.apply(Math, _toConsumableArray(xs));
  var x1 = Math.max.apply(Math, _toConsumableArray(xs));
  var y0 = Math.min.apply(Math, _toConsumableArray(ys));
  var y1 = Math.max.apply(Math, _toConsumableArray(ys));
  return {
    points: points,
    x: x0,
    y: y0,
    width: x1 - x0,
    height: y1 - y0
  };
};

var textPropsByEngine = {
  svg: {
    align: {
      left: 'start',
      center: 'middle',
      right: 'end'
    },
    baseline: {
      top: 'before-edge',
      center: 'central',
      bottom: 'after-edge'
    }
  },
  canvas: {
    align: {
      left: 'left',
      center: 'center',
      right: 'right'
    },
    baseline: {
      top: 'top',
      center: 'middle',
      bottom: 'bottom'
    }
  }
};

var getPolarLabelProps = function getPolarLabelProps(radius, angle, rotation) {
  var engine = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'svg';
  var textProps = textPropsByEngine[engine];
  var _positionFromAngle = positionFromAngle(angle - Math.PI / 2, radius),
      x = _positionFromAngle.x,
      y = _positionFromAngle.y;
  var rotate = radiansToDegrees(angle);
  var align = textProps.align.center;
  var baseline = textProps.baseline.bottom;
  if (rotation > 0) {
    align = textProps.align.right;
    baseline = textProps.baseline.center;
  } else if (rotation < 0) {
    align = textProps.align.left;
    baseline = textProps.baseline.center;
  }
  if (rotation !== 0 && rotate > 180) {
    rotate -= 180;
    align = align === textProps.align.right ? textProps.align.left : textProps.align.right;
  }
  rotate += rotation;
  return {
    x: x,
    y: y,
    rotate: rotate,
    align: align,
    baseline: baseline
  };
};

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$7(target, key, source[key]); }); } return target; }
function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var PatternLines = pure(function (_ref) {
  var id = _ref.id,
      _spacing = _ref.spacing,
      _rotation = _ref.rotation,
      background = _ref.background,
      color = _ref.color,
      lineWidth = _ref.lineWidth;
  var rotation = Math.round(_rotation) % 360;
  var spacing = Math.abs(_spacing);
  if (rotation > 180) rotation = rotation - 360;else if (rotation > 90) rotation = rotation - 180;else if (rotation < -180) rotation = rotation + 360;else if (rotation < -90) rotation = rotation + 180;
  var width = spacing;
  var height = spacing;
  var path;
  if (rotation === 0) {
    path = "\n                M 0 0 L ".concat(width, " 0\n                M 0 ").concat(height, " L ").concat(width, " ").concat(height, "\n            ");
  } else if (rotation === 90) {
    path = "\n                M 0 0 L 0 ".concat(height, "\n                M ").concat(width, " 0 L ").concat(width, " ").concat(height, "\n            ");
  } else {
    width = Math.abs(spacing / Math.sin(degreesToRadians(rotation)));
    height = spacing / Math.sin(degreesToRadians(90 - rotation));
    if (rotation > 0) {
      path = "\n                    M 0 ".concat(-height, " L ").concat(width * 2, " ").concat(height, "\n                    M ").concat(-width, " ").concat(-height, " L ").concat(width, " ").concat(height, "\n                    M ").concat(-width, " 0 L ").concat(width, " ").concat(height * 2, "\n                ");
    } else {
      path = "\n                    M ".concat(-width, " ").concat(height, " L ").concat(width, " ").concat(-height, "\n                    M ").concat(-width, " ").concat(height * 2, " L ").concat(width * 2, " ").concat(-height, "\n                    M 0 ").concat(height * 2, " L ").concat(width * 2, " 0\n                ");
    }
  }
  return React__default.createElement("pattern", {
    id: id,
    width: width,
    height: height,
    patternUnits: "userSpaceOnUse"
  }, React__default.createElement("rect", {
    width: width,
    height: height,
    fill: background,
    stroke: "rgba(255, 0, 0, 0.1)",
    strokeWidth: 0
  }), React__default.createElement("path", {
    d: path,
    strokeWidth: lineWidth,
    stroke: color,
    strokeLinecap: "square"
  }));
});
PatternLines.propTypes = {
  id: PropTypes.string.isRequired,
  spacing: PropTypes.number.isRequired,
  rotation: PropTypes.number.isRequired,
  background: PropTypes.string.isRequired,
  color: PropTypes.string.isRequired,
  lineWidth: PropTypes.number.isRequired
};
PatternLines.defaultProps = {
  spacing: 5,
  rotation: 0,
  color: '#000000',
  background: '#ffffff',
  lineWidth: 2
};
var patternLinesDef = function patternLinesDef(id) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread$6({
    id: id,
    type: 'patternLines'
  }, options);
};

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$8(target, key, source[key]); }); } return target; }
function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var PatternSquares = pure(function (_ref) {
  var id = _ref.id,
      background = _ref.background,
      color = _ref.color,
      size = _ref.size,
      padding = _ref.padding,
      stagger = _ref.stagger;
  var fullSize = size + padding;
  var halfPadding = padding / 2;
  if (stagger === true) {
    fullSize = size * 2 + padding * 2;
  }
  return React__default.createElement("pattern", {
    id: id,
    width: fullSize,
    height: fullSize,
    patternUnits: "userSpaceOnUse"
  }, React__default.createElement("rect", {
    width: fullSize,
    height: fullSize,
    fill: background
  }), React__default.createElement("rect", {
    x: halfPadding,
    y: halfPadding,
    width: size,
    height: size,
    fill: color
  }), stagger && React__default.createElement("rect", {
    x: padding * 1.5 + size,
    y: padding * 1.5 + size,
    width: size,
    height: size,
    fill: color
  }));
});
PatternSquares.propTypes = {
  id: PropTypes.string.isRequired,
  color: PropTypes.string.isRequired,
  background: PropTypes.string.isRequired,
  size: PropTypes.number.isRequired,
  padding: PropTypes.number.isRequired,
  stagger: PropTypes.bool.isRequired
};
PatternSquares.defaultProps = {
  color: '#000000',
  background: '#ffffff',
  size: 4,
  padding: 4,
  stagger: false
};
var patternSquaresDef = function patternSquaresDef(id) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread$7({
    id: id,
    type: 'patternSquares'
  }, options);
};

var patternTypes = {
  patternDots: PatternDots,
  patternLines: PatternLines,
  patternSquares: PatternSquares
};

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$9(target, key, source[key]); }); } return target; }
function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var defsMapping = _objectSpread$8({}, gradientTypes, patternTypes);
var Defs = pure(function (_ref) {
  var definitions = _ref.defs;
  if (!definitions || definitions.length < 1) return null;
  return React__default.createElement("defs", null, definitions.map(function (_ref2) {
    var type = _ref2.type,
        def = _objectWithoutProperties(_ref2, ["type"]);
    if (defsMapping[type]) return React__default.createElement(defsMapping[type], _objectSpread$8({
      key: def.id
    }, def));
    return null;
  }));
});
Defs.propTypes = {
  defs: PropTypes.arrayOf(PropTypes.shape({
    type: PropTypes.oneOf(Object.keys(defsMapping)).isRequired,
    id: PropTypes.string.isRequired
  }))
};

var SvgWrapper = function SvgWrapper(_ref) {
  var width = _ref.width,
      height = _ref.height,
      margin = _ref.margin,
      defs = _ref.defs,
      children = _ref.children,
      theme = _ref.theme;
  return React__default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    role: "img",
    width: width,
    height: height
  }, React__default.createElement(Defs, {
    defs: defs
  }), React__default.createElement("rect", {
    width: width,
    height: height,
    fill: theme.background
  }), React__default.createElement("g", {
    transform: "translate(".concat(margin.left, ",").concat(margin.top, ")")
  }, children));
};
SvgWrapper.propTypes = {
  width: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  margin: PropTypes.shape({
    top: PropTypes.number.isRequired,
    left: PropTypes.number.isRequired
  }).isRequired,
  defs: PropTypes.array,
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]).isRequired,
  theme: themePropType.isRequired
};

function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$a(target, key, source[key]); }); } return target; }
function _objectWithoutProperties$1(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$1(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }
function _possibleConstructorReturn$1(self, call) { if (call && (_typeof$1(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$1(self); }
function _getPrototypeOf$1(o) { _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$1(o); }
function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$1(subClass, superClass); }
function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }
function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var enhancedSpring = function enhancedSpring(value, config) {
  if (typeof value !== 'number') {
    return {
      value: value,
      config: config,
      interpolator: config && config.interpolator ? config.interpolator : d3Interpolate.interpolate
    };
  }
  return reactMotion.spring(value, config);
};
var SmartMotion =
function (_PureComponent) {
  _inherits$1(SmartMotion, _PureComponent);
  function SmartMotion() {
    var _getPrototypeOf2;
    var _this;
    _classCallCheck$1(this, SmartMotion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _possibleConstructorReturn$1(this, (_getPrototypeOf2 = _getPrototypeOf$1(SmartMotion)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _defineProperty$a(_assertThisInitialized$1(_this), "oldValues", {});
    _defineProperty$a(_assertThisInitialized$1(_this), "newInters", {});
    _defineProperty$a(_assertThisInitialized$1(_this), "currentStepValues", {});
    _defineProperty$a(_assertThisInitialized$1(_this), "stepValues", {});
    _defineProperty$a(_assertThisInitialized$1(_this), "stepInterpolators", {});
    return _this;
  }
  _createClass$1(SmartMotion, [{
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props = this.props,
          style = _this$props.style,
          children = _this$props.children,
          rest = _objectWithoutProperties$1(_this$props, ["style", "children"]);
      var resolvedStyle = style(enhancedSpring);
      for (var key in resolvedStyle) {
        if (
        resolvedStyle[key] && resolvedStyle[key].interpolator) {
          this.currentStepValues[key] = this.currentStepValues[key] || 0;
          if (
          typeof this.newInters[key] === 'undefined' || resolvedStyle[key].value !== this.newInters[key].value) {
            this.newInters[key] = resolvedStyle[key];
            this.stepValues[key] = this.currentStepValues[key] + 1;
            this.stepInterpolators[key] = this.newInters[key].interpolator(this.oldValues[key], this.newInters[key].value);
          }
          resolvedStyle[key] = reactMotion.spring(this.stepValues[key], this.newInters[key].config);
        }
      }
      return React__default.createElement(reactMotion.Motion, _extends({}, rest, {
        style: resolvedStyle
      }), function (values) {
        var newValues = {};
        for (var _key2 in values) {
          if (_this2.stepValues[_key2]) {
            _this2.currentStepValues[_key2] = values[_key2];
            var percentage = _this2.currentStepValues[_key2] - _this2.stepValues[_key2] + 1;
            _this2.oldValues[_key2] = newValues[_key2] = _this2.stepInterpolators[_key2](percentage);
          }
        }
        return children(_objectSpread$9({}, values, newValues));
      });
    }
  }]);
  return SmartMotion;
}(React.PureComponent);
_defineProperty$a(SmartMotion, "propTypes", {
  children: PropTypes.func.isRequired,
  style: PropTypes.func.isRequired
});

var DotsItemSymbol = function DotsItemSymbol(_ref) {
  var size = _ref.size,
      color = _ref.color,
      borderWidth = _ref.borderWidth,
      borderColor = _ref.borderColor;
  return React__default.createElement("circle", {
    r: size / 2,
    fill: color,
    stroke: borderColor,
    strokeWidth: borderWidth,
    style: {
      pointerEvents: 'none'
    }
  });
};
DotsItemSymbol.propTypes = {
  size: PropTypes.number.isRequired,
  color: PropTypes.string.isRequired,
  borderWidth: PropTypes.number.isRequired,
  borderColor: PropTypes.string.isRequired
};
var DotsItemSymbol$1 = pure(DotsItemSymbol);

var DotsItem = function DotsItem(_ref) {
  var x = _ref.x,
      y = _ref.y,
      symbol = _ref.symbol,
      size = _ref.size,
      datum = _ref.datum,
      color = _ref.color,
      borderWidth = _ref.borderWidth,
      borderColor = _ref.borderColor,
      label = _ref.label,
      labelTextAnchor = _ref.labelTextAnchor,
      labelYOffset = _ref.labelYOffset,
      theme = _ref.theme;
  return React__default.createElement("g", {
    transform: "translate(".concat(x, ", ").concat(y, ")"),
    style: {
      pointerEvents: 'none'
    }
  }, React__default.createElement(symbol, {
    size: size,
    color: color,
    datum: datum,
    borderWidth: borderWidth,
    borderColor: borderColor
  }), label && React__default.createElement("text", {
    textAnchor: labelTextAnchor,
    y: labelYOffset,
    style: theme.dots.text
  }, label));
};
DotsItem.propTypes = {
  x: PropTypes.number.isRequired,
  y: PropTypes.number.isRequired,
  datum: PropTypes.object.isRequired,
  size: PropTypes.number.isRequired,
  color: PropTypes.string.isRequired,
  borderWidth: PropTypes.number.isRequired,
  borderColor: PropTypes.string.isRequired,
  symbol: PropTypes.func.isRequired,
  label: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  labelTextAnchor: PropTypes.oneOf(['start', 'middle', 'end']),
  labelYOffset: PropTypes.number.isRequired,
  theme: PropTypes.shape({
    dots: dotsThemePropType.isRequired
  }).isRequired
};
var DotsItemDefaultProps = {
  symbol: DotsItemSymbol$1,
  labelTextAnchor: 'middle',
  labelYOffset: -12
};
DotsItem.defaultProps = DotsItemDefaultProps;
var DotsItem$1 = pure(DotsItem);

var memoizedColorModifier = memoize(function (method, _amount) {
  var amount = parseFloat(_amount);
  return memoize(function (d) {
    return d3Color.rgb(d.color)[method](amount)
    .toString();
  }, function (d) {
    return d.color;
  });
}, function (method, amount) {
  return "".concat(method, ".").concat(amount);
});
var noneGenerator = function noneGenerator() {
  return 'none';
};
var inheritGenerator = function inheritGenerator(d) {
  return d.color;
};
var getInheritedColorGenerator = function getInheritedColorGenerator(instruction, themeKey) {
  if (instruction === 'none') return noneGenerator;
  if (isFunction(instruction)) return instruction;
  if (instruction === 'theme') {
    if (!themeKey) {
      throw new Error("Cannot use 'theme' directive without providing 'themeKey'");
    }
    return function (d, theme) {
      return get(theme, themeKey);
    };
  }
  if (instruction === 'inherit') return inheritGenerator;
  var inheritMatches = instruction.match(/inherit:(darker|brighter)\(([0-9.]+)\)/);
  if (inheritMatches) {
    var method = inheritMatches[1];
    var amount = inheritMatches[2];
    return memoizedColorModifier(method, amount);
  }
  return function () {
    return instruction;
  };
};

var colorMotionSpring = function colorMotionSpring(_color, _config) {
  var color = d3Color.rgb(_color);
  if (!_config) return {
    colorR: color.r,
    colorG: color.g,
    colorB: color.b
  };
  var config = Object.assign({}, _config, {
    precision: 1
  });
  return {
    colorR: reactMotion.spring(color.r, config),
    colorG: reactMotion.spring(color.g, config),
    colorB: reactMotion.spring(color.b, config)
  };
};
var getInterpolatedColor = function getInterpolatedColor(_ref) {
  var colorR = _ref.colorR,
      colorG = _ref.colorG,
      colorB = _ref.colorB;
  return "rgb(".concat(Math.round(Math.max(colorR, 0)), ",").concat(Math.round(Math.max(colorG, 0)), ",").concat(Math.round(Math.max(colorB, 0)), ")");
};

var quantizeColorScales = {
  nivo: ['#d76445', '#f47560', '#e8c1a0', '#97e3d5', '#61cdbb', '#00b0a7'],
  BrBG: last(d3ScaleChromatic.schemeBrBG),
  PRGn: last(d3ScaleChromatic.schemePRGn),
  PiYG: last(d3ScaleChromatic.schemePiYG),
  PuOr: last(d3ScaleChromatic.schemePuOr),
  RdBu: last(d3ScaleChromatic.schemeRdBu),
  RdGy: last(d3ScaleChromatic.schemeRdGy),
  RdYlBu: last(d3ScaleChromatic.schemeRdYlBu),
  RdYlGn: last(d3ScaleChromatic.schemeRdYlGn),
  spectral: last(d3ScaleChromatic.schemeSpectral),
  blues: last(d3ScaleChromatic.schemeBlues),
  greens: last(d3ScaleChromatic.schemeGreens),
  greys: last(d3ScaleChromatic.schemeGreys),
  oranges: last(d3ScaleChromatic.schemeOranges),
  purples: last(d3ScaleChromatic.schemePurples),
  reds: last(d3ScaleChromatic.schemeReds),
  BuGn: last(d3ScaleChromatic.schemeBuGn),
  BuPu: last(d3ScaleChromatic.schemeBuPu),
  GnBu: last(d3ScaleChromatic.schemeGnBu),
  OrRd: last(d3ScaleChromatic.schemeOrRd),
  PuBuGn: last(d3ScaleChromatic.schemePuBuGn),
  PuBu: last(d3ScaleChromatic.schemePuBu),
  PuRd: last(d3ScaleChromatic.schemePuRd),
  RdPu: last(d3ScaleChromatic.schemeRdPu),
  YlGnBu: last(d3ScaleChromatic.schemeYlGnBu),
  YlGn: last(d3ScaleChromatic.schemeYlGn),
  YlOrBr: last(d3ScaleChromatic.schemeYlOrBr),
  YlOrRd: last(d3ScaleChromatic.schemeYlOrRd)
};
var quantizeColorScalesKeys = Object.keys(quantizeColorScales);
var guessQuantizeColorScale = function guessQuantizeColorScale(colors) {
  if (isFunction(colors)) {
    if (!isFunction(colors.domain)) {
      throw new Error("Provided colors should be a valid quantize scale providing a 'domain()' function");
    }
    return colors;
  }
  if (quantizeColorScales[colors]) {
    return d3Scale.scaleQuantize().range(quantizeColorScales[colors]);
  }
  if (isArray(colors)) return d3Scale.scaleQuantize().range(colors);
  throw new Error("Unable to guess quantize color scale from '".concat(colors, "',\nmust be a function or one of:\n'").concat(quantizeColorScalesKeys.join("', '"), "'"));
};

var colorSchemes = {
  nivo: ['#e8c1a0', '#f47560', '#f1e15b', '#e8a838', '#61cdbb', '#97e3d5'],
  category10: d3ScaleChromatic.schemeCategory10,
  accent: d3ScaleChromatic.schemeAccent,
  dark2: d3ScaleChromatic.schemeDark2,
  paired: d3ScaleChromatic.schemePaired,
  pastel1: d3ScaleChromatic.schemePastel1,
  pastel2: d3ScaleChromatic.schemePastel2,
  set1: d3ScaleChromatic.schemeSet1,
  set2: d3ScaleChromatic.schemeSet2,
  set3: d3ScaleChromatic.schemeSet3,
  brown_blueGreen: last(d3ScaleChromatic.schemeBrBG),
  purpleRed_green: last(d3ScaleChromatic.schemePRGn),
  pink_yellowGreen: last(d3ScaleChromatic.schemePiYG),
  purple_orange: last(d3ScaleChromatic.schemePuOr),
  red_blue: last(d3ScaleChromatic.schemeRdBu),
  red_grey: last(d3ScaleChromatic.schemeRdGy),
  red_yellow_blue: last(d3ScaleChromatic.schemeRdYlBu),
  red_yellow_green: last(d3ScaleChromatic.schemeRdYlGn),
  spectral: last(d3ScaleChromatic.schemeSpectral),
  blues: last(d3ScaleChromatic.schemeBlues),
  greens: last(d3ScaleChromatic.schemeGreens),
  greys: last(d3ScaleChromatic.schemeGreys),
  oranges: last(d3ScaleChromatic.schemeOranges),
  purples: last(d3ScaleChromatic.schemePurples),
  reds: last(d3ScaleChromatic.schemeReds),
  blue_green: last(d3ScaleChromatic.schemeBuGn),
  blue_purple: last(d3ScaleChromatic.schemeBuPu),
  green_blue: last(d3ScaleChromatic.schemeGnBu),
  orange_red: last(d3ScaleChromatic.schemeOrRd),
  purple_blue_green: last(d3ScaleChromatic.schemePuBuGn),
  purple_blue: last(d3ScaleChromatic.schemePuBu),
  purple_red: last(d3ScaleChromatic.schemePuRd),
  red_purple: last(d3ScaleChromatic.schemeRdPu),
  yellow_green_blue: last(d3ScaleChromatic.schemeYlGnBu),
  yellow_green: last(d3ScaleChromatic.schemeYlGn),
  yellow_orange_brown: last(d3ScaleChromatic.schemeYlOrBr),
  yellow_orange_red: last(d3ScaleChromatic.schemeYlOrRd)
};
var colorSchemeIds = ['nivo',
'category10', 'accent', 'dark2', 'paired', 'pastel1', 'pastel2', 'set1', 'set2', 'set3',
'brown_blueGreen', 'purpleRed_green', 'pink_yellowGreen', 'purple_orange', 'red_blue', 'red_grey', 'red_yellow_blue', 'red_yellow_green', 'spectral',
'blues', 'greens', 'greys', 'oranges', 'purples', 'reds',
'blue_green', 'blue_purple', 'green_blue', 'orange_red', 'purple_blue_green', 'purple_blue', 'purple_red', 'red_purple', 'yellow_green_blue', 'yellow_green', 'yellow_orange_brown', 'yellow_orange_red'];
var colorInterpolators = {
  brown_blueGreen: d3ScaleChromatic.interpolateBrBG,
  purpleRed_green: d3ScaleChromatic.interpolatePRGn,
  pink_yellowGreen: d3ScaleChromatic.interpolatePiYG,
  purple_orange: d3ScaleChromatic.interpolatePuOr,
  red_blue: d3ScaleChromatic.interpolateRdBu,
  red_grey: d3ScaleChromatic.interpolateRdGy,
  red_yellow_blue: d3ScaleChromatic.interpolateRdYlBu,
  red_yellow_green: d3ScaleChromatic.interpolateRdYlGn,
  spectral: d3ScaleChromatic.interpolateSpectral,
  blues: d3ScaleChromatic.interpolateBlues,
  greens: d3ScaleChromatic.interpolateGreens,
  greys: d3ScaleChromatic.interpolateGreys,
  oranges: d3ScaleChromatic.interpolateOranges,
  purples: d3ScaleChromatic.interpolatePurples,
  reds: d3ScaleChromatic.interpolateReds,
  viridis: d3ScaleChromatic.interpolateViridis,
  inferno: d3ScaleChromatic.interpolateInferno,
  magma: d3ScaleChromatic.interpolateMagma,
  plasma: d3ScaleChromatic.interpolatePlasma,
  warm: d3ScaleChromatic.interpolateWarm,
  cool: d3ScaleChromatic.interpolateCool,
  cubehelixDefault: d3ScaleChromatic.interpolateCubehelixDefault,
  blue_green: d3ScaleChromatic.interpolateBuGn,
  blue_purple: d3ScaleChromatic.interpolateBuPu,
  green_blue: d3ScaleChromatic.interpolateGnBu,
  orange_red: d3ScaleChromatic.interpolateOrRd,
  purple_blue_green: d3ScaleChromatic.interpolatePuBuGn,
  purple_blue: d3ScaleChromatic.interpolatePuBu,
  purple_red: d3ScaleChromatic.interpolatePuRd,
  red_purple: d3ScaleChromatic.interpolateRdPu,
  yellow_green_blue: d3ScaleChromatic.interpolateYlGnBu,
  yellow_green: d3ScaleChromatic.interpolateYlGn,
  yellow_orange_brown: d3ScaleChromatic.interpolateYlOrBr,
  yellow_orange_red: d3ScaleChromatic.interpolateYlOrRd,
  rainbow: d3ScaleChromatic.interpolateRainbow,
  sinebow: d3ScaleChromatic.interpolateSinebow
};
var colorInterpolatorIds = [
'brown_blueGreen', 'purpleRed_green', 'pink_yellowGreen', 'purple_orange', 'red_blue', 'red_grey', 'red_yellow_blue', 'red_yellow_green', 'spectral',
'blues', 'greens', 'greys', 'oranges', 'purples', 'reds',
'viridis', 'inferno', 'magma', 'plasma', 'warm', 'cool', 'cubehelixDefault', 'blue_green', 'blue_purple', 'green_blue', 'orange_red', 'purple_blue_green', 'purple_blue', 'purple_red', 'red_purple', 'yellow_green_blue', 'yellow_green', 'yellow_orange_brown', 'yellow_orange_red',
'rainbow', 'sinebow'];
var ordinalColorScales = {
  category10: d3Scale.scaleOrdinal(d3ScaleChromatic.schemeCategory10),
  accent: d3Scale.scaleOrdinal(d3ScaleChromatic.schemeAccent),
  dark2: d3Scale.scaleOrdinal(d3ScaleChromatic.schemeDark2),
  paired: d3Scale.scaleOrdinal(d3ScaleChromatic.schemePaired),
  pastel1: d3Scale.scaleOrdinal(d3ScaleChromatic.schemePastel1),
  pastel2: d3Scale.scaleOrdinal(d3ScaleChromatic.schemePastel2),
  set1: d3Scale.scaleOrdinal(d3ScaleChromatic.schemeSet1),
  set2: d3Scale.scaleOrdinal(d3ScaleChromatic.schemeSet2),
  set3: d3Scale.scaleOrdinal(d3ScaleChromatic.schemeSet3)
};
var nivoCategoricalColors = function nivoCategoricalColors() {
  return d3Scale.scaleOrdinal(['#e8c1a0', '#f47560', '#f1e15b', '#e8a838', '#61cdbb', '#97e3d5']);
};
var dataColor = function dataColor(d) {
  return d.color || d.data.color;
};
var getColorRange = function getColorRange(instruction) {
  if (instruction === 'data') return dataColor;
  if (instruction === 'nivo') return nivoCategoricalColors();
  if (isFunction(instruction)) return instruction;
  if (ordinalColorScales[instruction]) return ordinalColorScales[instruction];
  if (isArray(instruction)) return d3Scale.scaleOrdinal(instruction);
  return function () {
    return instruction;
  };
};
var getColorScale = function getColorScale(colors, dataScale) {
  if (isString(colors)) {
    var scheme = colorSchemes[colors];
    if (scheme !== undefined) {
      var scale = d3Scale.scaleOrdinal(scheme);
      scale.type = 'ordinal';
      return scale;
    }
    if (dataScale !== undefined && colors.indexOf('seq:') === 0) {
      var interpolator = colorInterpolators[colors.slice(4)];
      if (interpolator !== undefined) {
        var _scale = d3Scale.scaleSequential(interpolator).domain(dataScale.domain());
        _scale.type = 'sequential';
        return _scale;
      }
    }
  }
  if (isArray(colors)) {
    var _scale2 = d3Scale.scaleOrdinal(colors);
    _scale2.type = 'ordinal';
    return _scale2;
  }
  return function () {
    return colors;
  };
};
var getColorsGenerator = function getColorsGenerator(colors, colorBy) {
  if (isFunction(colorBy)) return colorBy;
  var scale;
  var getColorId = function getColorId(d) {
    return get(d, colorBy);
  };
  if (isString(colors) && colorSchemes[colors] !== undefined) {
    scale = d3Scale.scaleOrdinal(colorSchemes[colors]);
    scale.type = 'ordinal';
  } else if (isArray(colors)) {
    scale = d3Scale.scaleOrdinal(colors);
    scale.type = 'ordinal';
  } else {
    return function () {
      return colors;
    };
  }
  var colorGenerator = function colorGenerator(d) {
    return scale(getColorId(d));
  };
  colorGenerator.type = scale.type;
  return colorGenerator;
};

function _defineProperty$b(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var withColors = (function () {
  var _defaultProps, _setPropTypes;
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$colorsKey = _ref.colorsKey,
      colorsKey = _ref$colorsKey === void 0 ? 'colors' : _ref$colorsKey,
      _ref$colorByKey = _ref.colorByKey,
      colorByKey = _ref$colorByKey === void 0 ? 'colorBy' : _ref$colorByKey,
      _ref$destKey = _ref.destKey,
      destKey = _ref$destKey === void 0 ? 'getColor' : _ref$destKey,
      _ref$defaultColors = _ref.defaultColors,
      defaultColors = _ref$defaultColors === void 0 ? 'nivo' : _ref$defaultColors,
      _ref$defaultColorBy = _ref.defaultColorBy,
      defaultColorBy = _ref$defaultColorBy === void 0 ? 'id' : _ref$defaultColorBy;
  return compose(defaultProps((_defaultProps = {}, _defineProperty$b(_defaultProps, colorsKey, defaultColors), _defineProperty$b(_defaultProps, colorByKey, defaultColorBy), _defaultProps)), setPropTypes((_setPropTypes = {}, _defineProperty$b(_setPropTypes, colorsKey, PropTypes.any.isRequired), _defineProperty$b(_setPropTypes, colorByKey, PropTypes.oneOfType([PropTypes.string, PropTypes.func])), _setPropTypes)), withPropsOnChange([colorsKey, colorByKey], function (props) {
    return _defineProperty$b({}, destKey, getColorsGenerator(props[colorsKey], props[colorByKey]));
  }));
});

var quantizeColorScalePropType = PropTypes.oneOfType([PropTypes.oneOf(quantizeColorScalesKeys), PropTypes.func, PropTypes.arrayOf(PropTypes.string)]);

var curvePropMapping = {
  basis: d3Shape.curveBasis,
  basisClosed: d3Shape.curveBasisClosed,
  basisOpen: d3Shape.curveBasisOpen,
  bundle: d3Shape.curveBundle,
  cardinal: d3Shape.curveCardinal,
  cardinalClosed: d3Shape.curveCardinalClosed,
  cardinalOpen: d3Shape.curveCardinalOpen,
  catmullRom: d3Shape.curveCatmullRom,
  catmullRomClosed: d3Shape.curveCatmullRomClosed,
  catmullRomOpen: d3Shape.curveCatmullRomOpen,
  linear: d3Shape.curveLinear,
  linearClosed: d3Shape.curveLinearClosed,
  monotoneX: d3Shape.curveMonotoneX,
  monotoneY: d3Shape.curveMonotoneY,
  natural: d3Shape.curveNatural,
  step: d3Shape.curveStep,
  stepAfter: d3Shape.curveStepAfter,
  stepBefore: d3Shape.curveStepBefore
};
var curvePropKeys = Object.keys(curvePropMapping);
var curvePropType = PropTypes.oneOf(curvePropKeys);
var closedCurvePropKeys = curvePropKeys.filter(function (c) {
  return c.endsWith('Closed');
});
var closedCurvePropType = PropTypes.oneOf(closedCurvePropKeys);
var areaCurvePropKeys = without(curvePropKeys, 'bundle', 'basisClosed', 'basisOpen', 'cardinalClosed', 'cardinalOpen', 'catmullRomClosed', 'catmullRomOpen', 'linearClosed');
var areaCurvePropType = PropTypes.oneOf(areaCurvePropKeys);
var lineCurvePropKeys = without(curvePropKeys, 'bundle', 'basisClosed', 'basisOpen', 'cardinalClosed', 'cardinalOpen', 'catmullRomClosed', 'catmullRomOpen', 'linearClosed');
var lineCurvePropType = PropTypes.oneOf(lineCurvePropKeys);
var curveFromProp = function curveFromProp(id) {
  var curveInterpolator = curvePropMapping[id];
  if (!curveInterpolator) {
    throw new TypeError("'".concat(id, "', is not a valid curve interpolator identifier."));
  }
  return curvePropMapping[id];
};

var defsPropTypes = {
  defs: PropTypes.arrayOf(PropTypes.shape({
    id: PropTypes.string.isRequired
  })).isRequired,
  fill: PropTypes.arrayOf(PropTypes.shape({
    id: PropTypes.string.isRequired,
    match: PropTypes.oneOfType([PropTypes.oneOf(['*']), PropTypes.object, PropTypes.func]).isRequired
  })).isRequired
};

var stackOrderPropMapping = {
  ascending: d3Shape.stackOrderAscending,
  descending: d3Shape.stackOrderDescending,
  insideOut: d3Shape.stackOrderInsideOut,
  none: d3Shape.stackOrderNone,
  reverse: d3Shape.stackOrderReverse
};
var stackOrderPropKeys = Object.keys(stackOrderPropMapping);
var stackOrderPropType = PropTypes.oneOf(stackOrderPropKeys);
var stackOrderFromProp = function stackOrderFromProp(prop) {
  return stackOrderPropMapping[prop];
};
var stackOffsetPropMapping = {
  expand: d3Shape.stackOffsetExpand,
  diverging: d3Shape.stackOffsetDiverging,
  none: d3Shape.stackOffsetNone,
  silhouette: d3Shape.stackOffsetSilhouette,
  wiggle: d3Shape.stackOffsetWiggle
};
var stackOffsetPropKeys = Object.keys(stackOffsetPropMapping);
var stackOffsetPropType = PropTypes.oneOf(stackOffsetPropKeys);
var stackOffsetFromProp = function stackOffsetFromProp(prop) {
  return stackOffsetPropMapping[prop];
};

var treeMapTilePropMapping = {
  binary: d3Hierarchy.treemapBinary,
  dice: d3Hierarchy.treemapDice,
  slice: d3Hierarchy.treemapSlice,
  sliceDice: d3Hierarchy.treemapSliceDice,
  squarify: d3Hierarchy.treemapSquarify,
  resquarify: d3Hierarchy.treemapResquarify
};
var treeMapTilePropKeys = Object.keys(treeMapTilePropMapping);
var treeMapTilePropType = PropTypes.oneOf(treeMapTilePropKeys);
var treeMapTileFromProp = function treeMapTileFromProp(prop) {
  return treeMapTilePropMapping[prop];
};

var scalePropType = PropTypes.shape({
  type: PropTypes.string.isRequired,
  domain: PropTypes.array.isRequired,
  range: PropTypes.array.isRequired
});
var marginPropType = PropTypes.shape({
  top: PropTypes.number,
  right: PropTypes.number,
  bottom: PropTypes.number,
  left: PropTypes.number
}).isRequired;
var motionPropTypes = {
  animate: PropTypes.bool.isRequired,
  motionStiffness: PropTypes.number.isRequired,
  motionDamping: PropTypes.number.isRequired
};
var blendModePropType = PropTypes.oneOf(['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity']);

function _defineProperty$c(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var withCurve = (function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$srcKey = _ref.srcKey,
      srcKey = _ref$srcKey === void 0 ? 'curve' : _ref$srcKey,
      _ref$destKey = _ref.destKey,
      destKey = _ref$destKey === void 0 ? 'curveInterpolator' : _ref$destKey;
  return withProps(function (props) {
    return _defineProperty$c({}, destKey, curveFromProp(props[srcKey]));
  });
});

var defaultAnimate = true;
var defaultMotionStiffness = 90;
var defaultMotionDamping = 13;
var defaultCategoricalColors = nivoCategoricalColors;
var defaultColorRange = d3Scale.scaleOrdinal(d3ScaleChromatic.schemeSet3);
var defaultMargin = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};

var withDimensions = (function () {
  return compose(defaultProps({
    margin: defaultMargin
  }), setPropTypes({
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired,
    margin: marginPropType
  }), withPropsOnChange(function (props, nextProps) {
    return props.width !== nextProps.width || props.height !== nextProps.height || !isEqual(props.margin, nextProps.margin);
  }, function (props) {
    var margin = Object.assign({}, defaultMargin, props.margin);
    return {
      margin: margin,
      width: props.width - margin.left - margin.right,
      height: props.height - margin.top - margin.bottom,
      outerWidth: props.width,
      outerHeight: props.height
    };
  }));
});

var getLabelGenerator = function getLabelGenerator(_label, labelFormat) {
  var getRawLabel = isFunction(_label) ? _label : function (d) {
    return get(d, _label);
  };
  var formatter;
  if (labelFormat) {
    formatter = isFunction(labelFormat) ? labelFormat : d3Format.format(labelFormat);
  }
  if (formatter) return function (d) {
    return formatter(getRawLabel(d));
  };
  return getRawLabel;
};
var getAccessorFor = function getAccessorFor(directive) {
  return isFunction(directive) ? directive : function (d) {
    return d[directive];
  };
};
var getAccessorOrValue = function getAccessorOrValue(value) {
  return isFunction(value) ? value : function () {
    return value;
  };
};

function _defineProperty$d(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var withHierarchy = (function () {
  var _setPropTypes;
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$srcKey = _ref.srcKey,
      srcKey = _ref$srcKey === void 0 ? 'root' : _ref$srcKey,
      _ref$destKey = _ref.destKey,
      destKey = _ref$destKey === void 0 ? 'root' : _ref$destKey,
      _ref$valueKey = _ref.valueKey,
      valueKey = _ref$valueKey === void 0 ? 'value' : _ref$valueKey,
      _ref$valueDefault = _ref.valueDefault,
      valueDefault = _ref$valueDefault === void 0 ? 'value' : _ref$valueDefault;
  return compose(defaultProps(_defineProperty$d({}, valueKey, valueDefault)), setPropTypes((_setPropTypes = {}, _defineProperty$d(_setPropTypes, srcKey, PropTypes.object.isRequired), _defineProperty$d(_setPropTypes, valueKey, PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired), _setPropTypes)), withPropsOnChange([srcKey, valueKey], function (props) {
    return _defineProperty$d({}, destKey, d3Hierarchy.hierarchy(props[srcKey]).sum(getAccessorFor(props[valueKey])));
  }));
});

var withMotion = (function () {
  return compose(setPropTypes(motionPropTypes), defaultProps({
    animate: defaultAnimate,
    motionDamping: defaultMotionDamping,
    motionStiffness: defaultMotionStiffness
  }), withPropsOnChange(['motionDamping', 'motionStiffness'], function (_ref) {
    var motionDamping = _ref.motionDamping,
        motionStiffness = _ref.motionStiffness;
    return {
      boundSpring: partialRight(reactMotion.spring, {
        damping: motionDamping,
        stiffness: motionStiffness
      })
    };
  }));
});

function _defineProperty$e(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var withTheme = (function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$srcKey = _ref.srcKey,
      srcKey = _ref$srcKey === void 0 ? 'theme' : _ref$srcKey,
      _ref$destKey = _ref.destKey,
      destKey = _ref$destKey === void 0 ? 'theme' : _ref$destKey;
  return compose(setPropTypes(_defineProperty$e({}, srcKey, PropTypes.object)), withPropsOnChange([srcKey], function (props) {
    return _defineProperty$e({}, destKey, extendDefaultTheme(defaultTheme, props[srcKey]));
  }));
});

function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$f(target, key, source[key]); }); } return target; }
function _defineProperty$f(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var useDimensions = function useDimensions(width, height) {
  var partialMargin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return React.useMemo(function () {
    var margin = _objectSpread$a({}, defaultMargin, partialMargin);
    return {
      margin: margin,
      innerWidth: width - margin.left - margin.right,
      innerHeight: height - margin.top - margin.bottom,
      outerWidth: width,
      outerHeight: height
    };
  }, [width, height, partialMargin.top, partialMargin.right, partialMargin.bottom, partialMargin.left]);
};

var usePartialTheme = function usePartialTheme(partialTheme) {
  return React.useMemo(function () {
    return extendDefaultTheme(defaultTheme, partialTheme);
  }, [partialTheme]);
};

function _typeof$2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }
function _objectWithoutProperties$2(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$2(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose$2(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }
function _possibleConstructorReturn$2(self, call) { if (call && (_typeof$2(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$2(self); }
function _assertThisInitialized$2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _getPrototypeOf$2(o) { _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$2(o); }
function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$2(subClass, superClass); }
function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }
function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$g(target, key, source[key]); }); } return target; }
function _defineProperty$g(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _slicedToArray$2(arr, i) { return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _nonIterableRest$2(); }
function _nonIterableRest$2() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }
function _iterableToArrayLimit$2(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles$2(arr) { if (Array.isArray(arr)) return arr; }
var containerStyle$1 = {
  position: 'relative'
};
var tooltipStyle$1 = {
  pointerEvents: 'none',
  position: 'absolute',
  zIndex: 10
};
var Container$1 = function Container(_ref) {
  var _ref$theme = _ref.theme,
      partialTheme = _ref$theme === void 0 ? {} : _ref$theme,
      children = _ref.children;
  var containerEl = React.useRef(null);
  var _useState = React.useState({
    isTooltipVisible: false,
    tooltipContent: null,
    position: {}
  }),
      _useState2 = _slicedToArray$2(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];
  var showTooltip = React.useCallback(function (content, event) {
    if (!containerEl) return;
    var bounds = containerEl.current.getBoundingClientRect();
    var clientX = event.clientX,
        clientY = event.clientY;
    var x = clientX - bounds.left;
    var y = clientY - bounds.top;
    var position = {};
    if (x < bounds.width / 2) position.left = x + 20;else position.right = bounds.width - x + 20;
    if (y < bounds.height / 2) position.top = y - 12;else position.bottom = bounds.height - y - 12;
    setState({
      isTooltipVisible: true,
      tooltipContent: content,
      position: position
    });
  }, [containerEl]);
  var hideTooltip = React.useCallback(function () {
    setState({
      isTooltipVisible: false,
      tooltipContent: null
    });
  });
  var isTooltipVisible = state.isTooltipVisible,
      tooltipContent = state.tooltipContent,
      position = state.position;
  var theme = usePartialTheme(partialTheme);
  return React__default.createElement(themeContext.Provider, {
    value: theme
  }, React__default.createElement(tooltipContext.Provider, {
    value: [showTooltip, hideTooltip]
  }, React__default.createElement("div", {
    style: containerStyle$1,
    ref: containerEl
  }, children, isTooltipVisible && React__default.createElement("div", {
    style: _objectSpread$b({}, tooltipStyle$1, position, theme.tooltip)
  }, tooltipContent))));
};
Container$1.propTypes = {
  children: PropTypes.node.isRequired,
  theme: PropTypes.object
};
var withContainer = function withContainer(WrappedComponent) {
  return (
    function (_Component) {
      _inherits$2(_class, _Component);
      function _class() {
        _classCallCheck$2(this, _class);
        return _possibleConstructorReturn$2(this, _getPrototypeOf$2(_class).apply(this, arguments));
      }
      _createClass$2(_class, [{
        key: "render",
        value: function render() {
          var _this$props = this.props,
              theme = _this$props.theme,
              rest = _objectWithoutProperties$2(_this$props, ["theme"]);
          return React__default.createElement(Container$1, {
            theme: theme
          }, React__default.createElement(WrappedComponent, rest));
        }
      }]);
      return _class;
    }(React.Component)
  );
};

function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$h(target, key, source[key]); }); } return target; }
function _defineProperty$h(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var horizontalPositions = ['top', 'bottom'];
var verticalPositions = ['left', 'right'];
var centerScale = function centerScale(scale) {
  var bandwidth = scale.bandwidth();
  if (bandwidth === 0) return scale;
  var offset = bandwidth / 2;
  if (scale.round()) {
    offset = Math.round(offset);
  }
  return function (d) {
    return scale(d) + offset;
  };
};
var getScaleValues = function getScaleValues(scale, tickCount) {
  if (scale.ticks) return scale.ticks(tickCount);
  return scale.domain();
};
var computeAxisTicks = function computeAxisTicks(_ref) {
  var width = _ref.width,
      height = _ref.height,
      _position = _ref.position,
      scale = _ref.scale,
      _tickValues = _ref.tickValues,
      _ref$tickSize = _ref.tickSize,
      tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,
      _ref$tickPadding = _ref.tickPadding,
      tickPadding = _ref$tickPadding === void 0 ? 5 : _ref$tickPadding,
      _ref$tickRotation = _ref.tickRotation,
      tickRotation = _ref$tickRotation === void 0 ? 0 : _ref$tickRotation,
      _ref$engine = _ref.engine,
      engine = _ref$engine === void 0 ? 'svg' : _ref$engine;
  var tickValues = isArray(_tickValues) ? _tickValues : undefined;
  var tickCount = isNumber(_tickValues) ? _tickValues : undefined;
  var values = tickValues || getScaleValues(scale, tickCount);
  var textProps = textPropsByEngine[engine];
  var orient = _position;
  var position = scale.bandwidth ? centerScale(scale) : scale;
  var line = {
    lineX: 0,
    lineY: 0
  };
  var text = {
    textX: 0,
    textY: 0
  };
  var x = 0;
  var y = 0;
  var translate;
  var textAlign = textProps.align.center;
  var textBaseline = textProps.baseline.center;
  if (horizontalPositions.includes(orient)) {
    translate = function translate(d) {
      return {
        x: position(d),
        y: 0
      };
    };
    line.lineY = tickSize * (orient === 'bottom' ? 1 : -1);
    text.textY = (tickSize + tickPadding) * (orient === 'bottom' ? 1 : -1);
    if (orient === 'bottom') {
      y = height;
      textBaseline = textProps.baseline.top;
    } else {
      textBaseline = textProps.baseline.bottom;
    }
    if (tickRotation === 0) {
      textAlign = textProps.align.center;
    } else if (orient === 'bottom' && tickRotation < 0 || orient === 'top' && tickRotation > 0) {
      textAlign = textProps.align.right;
      textBaseline = textProps.baseline.center;
    } else if (orient === 'bottom' && tickRotation > 0 || orient === 'top' && tickRotation < 0) {
      textAlign = textProps.align.left;
      textBaseline = textProps.baseline.center;
    }
  } else if (verticalPositions.includes(orient)) {
    translate = function translate(d) {
      return {
        x: 0,
        y: position(d)
      };
    };
    line.lineX = tickSize * (orient === 'right' ? 1 : -1);
    text.textX = (tickSize + tickPadding) * (orient === 'right' ? 1 : -1);
    if (orient === 'right') {
      x = width;
      textAlign = textProps.align.left;
    } else {
      textAlign = textProps.align.right;
    }
  }
  var ticks = values.map(function (value) {
    return _objectSpread$c({
      key: value,
      value: value
    }, translate(value), line, text);
  });
  return {
    x: x,
    y: y,
    ticks: ticks,
    textAlign: textAlign,
    textBaseline: textBaseline
  };
};
var computeGridLines = function computeGridLines(_ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      scale = _ref2.scale,
      axis = _ref2.axis,
      _values = _ref2.values;
  var gridValues = isArray(_values) ? _values : undefined;
  var gridCount = isNumber(_values) ? _values : undefined;
  var values = gridValues || getScaleValues(scale, gridCount);
  var position = scale.bandwidth ? centerScale(scale) : scale;
  var lines;
  if (axis === 'x') {
    lines = values.map(function (v) {
      return {
        key: "".concat(v),
        x1: position(v),
        x2: position(v),
        y1: 0,
        y2: height
      };
    });
  } else if (axis === 'y') {
    lines = values.map(function (v) {
      return {
        key: "".concat(v),
        x1: 0,
        x2: width,
        y1: position(v),
        y2: position(v)
      };
    });
  }
  return lines;
};

function _typeof$3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }
function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }
function _possibleConstructorReturn$3(self, call) { if (call && (_typeof$3(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$3(self); }
function _assertThisInitialized$3(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _getPrototypeOf$3(o) { _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$3(o); }
function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$3(subClass, superClass); }
function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }
function _defineProperty$i(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var AxisTick =
function (_Component) {
  _inherits$3(AxisTick, _Component);
  function AxisTick() {
    _classCallCheck$3(this, AxisTick);
    return _possibleConstructorReturn$3(this, _getPrototypeOf$3(AxisTick).apply(this, arguments));
  }
  _createClass$3(AxisTick, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          _value = _this$props.value,
          x = _this$props.x,
          y = _this$props.y,
          opacity = _this$props.opacity,
          rotate = _this$props.rotate,
          format = _this$props.format,
          lineX = _this$props.lineX,
          lineY = _this$props.lineY,
          _onClick = _this$props.onClick,
          textX = _this$props.textX,
          textY = _this$props.textY,
          textBaseline = _this$props.textBaseline,
          textAnchor = _this$props.textAnchor,
          theme = _this$props.theme;
      var value = _value;
      if (format !== undefined) {
        value = format(value);
      }
      var gStyle = {
        opacity: opacity
      };
      if (_onClick) {
        gStyle['cursor'] = 'pointer';
      }
      return React__default.createElement("g", _extends$1({
        transform: "translate(".concat(x, ",").concat(y, ")")
      }, _onClick ? {
        onClick: function onClick(e) {
          return _onClick(e, value);
        }
      } : {}, {
        style: gStyle
      }), React__default.createElement("line", {
        x1: 0,
        x2: lineX,
        y1: 0,
        y2: lineY,
        style: theme.axis.ticks.line
      }), React__default.createElement("text", {
        alignmentBaseline: textBaseline,
        textAnchor: textAnchor,
        transform: "translate(".concat(textX, ",").concat(textY, ") rotate(").concat(rotate, ")"),
        style: theme.axis.ticks.text
      }, value));
    }
  }]);
  return AxisTick;
}(React.Component);
_defineProperty$i(AxisTick, "propTypes", {
  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,
  format: PropTypes.func,
  x: PropTypes.number.isRequired,
  y: PropTypes.number.isRequired,
  lineX: PropTypes.number.isRequired,
  lineY: PropTypes.number.isRequired,
  textX: PropTypes.number.isRequired,
  textY: PropTypes.number.isRequired,
  textBaseline: PropTypes.string.isRequired,
  textAnchor: PropTypes.string.isRequired,
  opacity: PropTypes.number.isRequired,
  rotate: PropTypes.number.isRequired,
  onClick: PropTypes.func,
  theme: PropTypes.shape({
    axis: axisThemePropType.isRequired
  }).isRequired
});
_defineProperty$i(AxisTick, "defaultProps", {
  opacity: 1,
  rotate: 0
});

function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$j(target, key, source[key]); }); } return target; }
function _defineProperty$j(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }
var axisPositions = ['top', 'right', 'bottom', 'left'];
var legendPositions = ['start', 'center', 'end'];
var axisPropType = PropTypes.shape({
  orient: PropTypes.oneOf(axisPositions),
  tickValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]))]),
  tickSize: PropTypes.number,
  tickPadding: PropTypes.number,
  tickRotation: PropTypes.number,
  format: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  legend: PropTypes.node,
  legendPosition: PropTypes.oneOf(legendPositions),
  legendOffset: PropTypes.number
});
var willEnter = function willEnter() {
  return {
    opacity: 0,
    x: 0,
    y: 0
  };
};
var willLeave = function willLeave(springConfig) {
  return function (_ref) {
    var _ref$style = _ref.style,
        x = _ref$style.x,
        y = _ref$style.y;
    return {
      opacity: reactMotion.spring(0, springConfig),
      x: reactMotion.spring(x.val, springConfig),
      y: reactMotion.spring(y.val, springConfig)
    };
  };
};
var Axis = function Axis(_ref2) {
  var scale = _ref2.scale,
      width = _ref2.width,
      height = _ref2.height,
      _position = _ref2.position,
      tickValues = _ref2.tickValues,
      tickSize = _ref2.tickSize,
      tickPadding = _ref2.tickPadding,
      tickRotation = _ref2.tickRotation,
      format = _ref2.format,
      _legend = _ref2.legend,
      legendPosition = _ref2.legendPosition,
      legendOffset = _ref2.legendOffset,
      theme = _ref2.theme,
      animate = _ref2.animate,
      motionStiffness = _ref2.motionStiffness,
      motionDamping = _ref2.motionDamping,
      onClick = _ref2.onClick;
  var _computeAxisTicks = computeAxisTicks({
    width: width,
    height: height,
    scale: scale,
    position: _position,
    tickValues: tickValues,
    tickSize: tickSize,
    tickPadding: tickPadding,
    tickRotation: tickRotation
  }),
      x = _computeAxisTicks.x,
      y = _computeAxisTicks.y,
      ticks = _computeAxisTicks.ticks,
      textAlign = _computeAxisTicks.textAlign,
      textBaseline = _computeAxisTicks.textBaseline;
  var isHorizontal = ['top', 'bottom'].includes(_position);
  var isVertical = !isHorizontal;
  var legend = null;
  if (_legend !== undefined) {
    var legendX = 0;
    var legendY = 0;
    var legendRotation = 0;
    var textAnchor;
    if (isVertical) {
      legendRotation = -90;
      legendX = legendOffset;
      if (legendPosition === 'start') {
        textAnchor = 'start';
        legendY = height;
      } else if (legendPosition === 'center') {
        textAnchor = 'middle';
        legendY = height / 2;
      } else if (legendPosition === 'end') {
        textAnchor = 'end';
      }
    } else {
      legendY = legendOffset;
      if (legendPosition === 'start') {
        textAnchor = 'start';
      } else if (legendPosition === 'center') {
        textAnchor = 'middle';
        legendX = width / 2;
      } else if (legendPosition === 'end') {
        textAnchor = 'end';
        legendX = width;
      }
    }
    legend = React__default.createElement("text", {
      transform: "translate(".concat(legendX, ", ").concat(legendY, ") rotate(").concat(legendRotation, ")"),
      textAnchor: textAnchor,
      style: theme.axis.legend.text
    }, _legend);
  }
  var tickElements;
  if (!animate) {
    tickElements = React__default.createElement("g", null, ticks.map(function (tick) {
      return React__default.createElement(AxisTick, _extends$2({
        key: tick.key,
        value: tick.key,
        format: format,
        lineX: tick.lineX,
        lineY: tick.lineY,
        rotate: tickRotation,
        textX: tick.textX,
        textY: tick.textY,
        textBaseline: textBaseline,
        textAnchor: textAlign,
        theme: theme,
        x: tick.x,
        y: tick.y
      }, onClick ? {
        onClick: onClick
      } : {}));
    }));
  } else {
    var springConfig = {
      stiffness: motionStiffness,
      damping: motionDamping
    };
    tickElements = React__default.createElement(reactMotion.TransitionMotion, {
      willEnter: willEnter,
      willLeave: willLeave(springConfig),
      styles: ticks.map(function (tick) {
        return {
          key: "".concat(tick.key),
          data: tick,
          style: {
            opacity: reactMotion.spring(1, springConfig),
            x: reactMotion.spring(tick.x, springConfig),
            y: reactMotion.spring(tick.y, springConfig)
          }
        };
      })
    }, function (interpolatedStyles) {
      return React__default.createElement("g", null, interpolatedStyles.map(function (_ref3) {
        var key = _ref3.key,
            style = _ref3.style,
            tick = _ref3.data;
        return React__default.createElement(AxisTick, _extends$2({
          key: key,
          value: key,
          format: format,
          lineX: tick.lineX,
          lineY: tick.lineY,
          rotate: tickRotation,
          textX: tick.textX,
          textY: tick.textY,
          textBaseline: textBaseline,
          textAnchor: textAlign,
          theme: theme
        }, onClick ? {
          onClick: onClick
        } : {}, style));
      }));
    });
  }
  return React__default.createElement("g", {
    transform: "translate(".concat(x, ",").concat(y, ")")
  }, legend, tickElements, React__default.createElement("line", {
    style: theme.axis.domain.line,
    x1: 0,
    x2: isHorizontal ? width : 0,
    y1: 0,
    y2: isHorizontal ? 0 : height
  }));
};
Axis.propTypes = _objectSpread$d({
  width: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  position: PropTypes.oneOf(axisPositions).isRequired,
  scale: PropTypes.func.isRequired,
  tickValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]))]),
  tickSize: PropTypes.number.isRequired,
  tickPadding: PropTypes.number.isRequired,
  tickRotation: PropTypes.number.isRequired,
  format: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  legend: PropTypes.node,
  legendPosition: PropTypes.oneOf(legendPositions).isRequired,
  legendOffset: PropTypes.number.isRequired,
  theme: PropTypes.shape({
    axis: axisThemePropType.isRequired
  }).isRequired,
  onClick: PropTypes.func
}, motionPropTypes);
Axis.defaultProps = {
  tickSize: 5,
  tickPadding: 5,
  tickRotation: 0,
  legendPosition: 'end',
  legendOffset: 0
};
var enhance = compose(withMotion(), withPropsOnChange(['format', 'scale'], function (_ref4) {
  var format = _ref4.format,
      scale = _ref4.scale;
  if (!format || isFunction(format)) {
    return {
      format: format
    };
  } else if (scale.type === 'time') {
    var f = d3TimeFormat.timeFormat(format);
    return {
      format: function format(d) {
        return f(new Date(d));
      }
    };
  } else {
    return {
      format: d3Format.format(format)
    };
  }
}), pure);
var Axis$1 = enhance(Axis);

function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$k(target, key, source[key]); }); } return target; }
function _defineProperty$k(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
var horizontalPositions$1 = ['top', 'bottom'];
var verticalPositions$1 = ['left', 'right'];
var positions = [].concat(horizontalPositions$1, verticalPositions$1);
var Axes = function Axes(_ref) {
  var xScale = _ref.xScale,
      yScale = _ref.yScale,
      width = _ref.width,
      height = _ref.height,
      top = _ref.top,
      right = _ref.right,
      bottom = _ref.bottom,
      left = _ref.left,
      theme = _ref.theme,
      animate = _ref.animate,
      motionStiffness = _ref.motionStiffness,
      motionDamping = _ref.motionDamping;
  var axes = {
    top: top,
    right: right,
    bottom: bottom,
    left: left
  };
  return React__default.createElement("g", null, positions.map(function (position) {
    var axis = axes[position];
    if (!axis) return null;
    var scale = horizontalPositions$1.includes(position) ? xScale : yScale;
    return React__default.createElement(Axis$1, _extends$3({
      theme: theme
    }, axis, {
      key: position,
      width: width,
      height: height,
      position: position,
      scale: scale,
      animate: animate,
      motionDamping: motionDamping,
      motionStiffness: motionStiffness
    }));
  }));
};
Axes.propTypes = _objectSpread$e({
  xScale: PropTypes.func.isRequired,
  yScale: PropTypes.func.isRequired,
  width: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  top: axisPropType,
  right: axisPropType,
  bottom: axisPropType,
  left: axisPropType,
  theme: PropTypes.shape({
    axis: axisThemePropType.isRequired
  }).isRequired
}, motionPropTypes);
var Axes$1 = shouldUpdate(function (props, nextProps) {
  return props.xScale !== nextProps.xScale || props.yScale !== nextProps.yScale || props.width !== nextProps.width || props.height !== nextProps.height || props.theme !== nextProps.theme || props.animate !== nextProps.animate || props.motionDamping !== nextProps.motionDamping || props.motionStiffness !== nextProps.motionStiffness || !isEqual(props.top, nextProps.top) || !isEqual(props.right, nextProps.right) || !isEqual(props.bottom, nextProps.bottom) || !isEqual(props.left, nextProps.left);
})(Axes);

var GridLine = function GridLine(props) {
  return React__default.createElement("line", props);
};
GridLine.propTypes = {
  x1: PropTypes.number.isRequired,
  x2: PropTypes.number.isRequired,
  y1: PropTypes.number.isRequired,
  y2: PropTypes.number.isRequired
};
GridLine.defaultProps = {
  x1: 0,
  x2: 0,
  y1: 0,
  y2: 0
};

function _typeof$4(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$4(obj); }
function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }
function _possibleConstructorReturn$4(self, call) { if (call && (_typeof$4(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$4(self); }
function _getPrototypeOf$4(o) { _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$4(o); }
function _assertThisInitialized$4(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$4(subClass, superClass); }
function _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }
function _defineProperty$l(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var GridLines =
function (_Component) {
  _inherits$4(GridLines, _Component);
  function GridLines(props) {
    var _this;
    _classCallCheck$4(this, GridLines);
    _this = _possibleConstructorReturn$4(this, _getPrototypeOf$4(GridLines).call(this, props));
    _this.willEnter = _this.willEnter.bind(_assertThisInitialized$4(_this));
    _this.willLeave = _this.willLeave.bind(_assertThisInitialized$4(_this));
    return _this;
  }
  _createClass$4(GridLines, [{
    key: "willEnter",
    value: function willEnter(_ref) {
      var style = _ref.style;
      var type = this.props.type;
      return {
        opacity: 0,
        x1: type === 'x' ? 0 : style.x1.val,
        x2: type === 'x' ? 0 : style.x2.val,
        y1: type === 'y' ? 0 : style.y1.val,
        y2: type === 'y' ? 0 : style.y2.val
      };
    }
  }, {
    key: "willLeave",
    value: function willLeave(_ref2) {
      var style = _ref2.style;
      var _this$props = this.props,
          motionStiffness = _this$props.motionStiffness,
          motionDamping = _this$props.motionDamping;
      var springConfig = {
        stiffness: motionStiffness,
        damping: motionDamping
      };
      return {
        opacity: reactMotion.spring(0, springConfig),
        x1: reactMotion.spring(style.x1.val, springConfig),
        x2: reactMotion.spring(style.x2.val, springConfig),
        y1: reactMotion.spring(style.y1.val, springConfig),
        y2: reactMotion.spring(style.y2.val, springConfig)
      };
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          lines = _this$props2.lines,
          animate = _this$props2.animate,
          motionStiffness = _this$props2.motionStiffness,
          motionDamping = _this$props2.motionDamping,
          theme = _this$props2.theme;
      if (!animate) {
        return React__default.createElement("g", null, lines.map(function (line) {
          return React__default.createElement(GridLine, _extends$4({
            key: line.key
          }, line, theme.grid.line));
        }));
      }
      var springConfig = {
        stiffness: motionStiffness,
        damping: motionDamping
      };
      return React__default.createElement(reactMotion.TransitionMotion, {
        willEnter: this.willEnter,
        willLeave: this.willLeave,
        styles: lines.map(function (line) {
          return {
            key: line.key,
            style: {
              opacity: reactMotion.spring(1, springConfig),
              x1: reactMotion.spring(line.x1 || 0, springConfig),
              x2: reactMotion.spring(line.x2 || 0, springConfig),
              y1: reactMotion.spring(line.y1 || 0, springConfig),
              y2: reactMotion.spring(line.y2 || 0, springConfig)
            }
          };
        })
      }, function (interpolatedStyles) {
        return React__default.createElement("g", null, interpolatedStyles.map(function (interpolatedStyle) {
          var key = interpolatedStyle.key,
              style = interpolatedStyle.style;
          return React__default.createElement(GridLine, _extends$4({
            key: key
          }, theme.grid.line, style));
        }));
      });
    }
  }]);
  return GridLines;
}(React.Component);
_defineProperty$l(GridLines, "propTypes", {
  type: PropTypes.oneOf(['x', 'y']).isRequired,
  lines: PropTypes.arrayOf(PropTypes.shape({
    key: PropTypes.string.isRequired,
    x1: PropTypes.number,
    x2: PropTypes.number,
    y1: PropTypes.number,
    y2: PropTypes.number
  })).isRequired,
  theme: PropTypes.object.isRequired,
  animate: PropTypes.bool.isRequired,
  motionStiffness: PropTypes.number.isRequired,
  motionDamping: PropTypes.number.isRequired
});

function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$m(target, key, source[key]); }); } return target; }
function _defineProperty$m(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Grid = function Grid(_ref) {
  var width = _ref.width,
      height = _ref.height,
      xScale = _ref.xScale,
      yScale = _ref.yScale,
      xValues = _ref.xValues,
      yValues = _ref.yValues,
      theme = _ref.theme,
      animate = _ref.animate,
      motionStiffness = _ref.motionStiffness,
      motionDamping = _ref.motionDamping;
  var xLines = xScale ? computeGridLines({
    width: width,
    height: height,
    scale: xScale,
    axis: 'x',
    values: xValues
  }) : false;
  var yLines = yScale ? computeGridLines({
    width: width,
    height: height,
    scale: yScale,
    axis: 'y',
    values: yValues
  }) : false;
  return React__default.createElement("g", null, xLines && React__default.createElement(GridLines, {
    type: "x",
    lines: xLines,
    theme: theme,
    animate: animate,
    motionStiffness: motionStiffness,
    motionDamping: motionDamping
  }), yLines && React__default.createElement(GridLines, {
    type: "y",
    lines: yLines,
    theme: theme,
    animate: animate,
    motionStiffness: motionStiffness,
    motionDamping: motionDamping
  }));
};
Grid.propTypes = _objectSpread$f({
  width: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  xScale: PropTypes.func,
  yScale: PropTypes.func,
  xValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]))]),
  yValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]))]),
  theme: PropTypes.object.isRequired
}, motionPropTypes);
Grid.defaultProps = {
  animate: true,
  motionStiffness: defaultMotionStiffness,
  motionDamping: defaultMotionDamping
};
var Grid$1 = pure(Grid);

var computeLabel = function computeLabel(_ref) {
  var axis = _ref.axis,
      width = _ref.width,
      height = _ref.height,
      position = _ref.position,
      offsetX = _ref.offsetX,
      offsetY = _ref.offsetY,
      orientation = _ref.orientation;
  var x = 0;
  var y = 0;
  var rotation = orientation === 'vertical' ? -90 : 0;
  var textAnchor = 'start';
  if (axis === 'x') {
    switch (position) {
      case 'top-left':
        x = -offsetX;
        y = offsetY;
        textAnchor = 'end';
        break;
      case 'top':
        y = -offsetY;
        if (orientation === 'horizontal') {
          textAnchor = 'middle';
        } else {
          textAnchor = 'start';
        }
        break;
      case 'top-right':
        x = offsetX;
        y = offsetY;
        if (orientation === 'horizontal') {
          textAnchor = 'start';
        } else {
          textAnchor = 'end';
        }
        break;
      case 'right':
        x = offsetX;
        y = height / 2;
        if (orientation === 'horizontal') {
          textAnchor = 'start';
        } else {
          textAnchor = 'middle';
        }
        break;
      case 'bottom-right':
        x = offsetX;
        y = height - offsetY;
        textAnchor = 'start';
        break;
      case 'bottom':
        y = height + offsetY;
        if (orientation === 'horizontal') {
          textAnchor = 'middle';
        } else {
          textAnchor = 'end';
        }
        break;
      case 'bottom-left':
        y = height - offsetY;
        x = -offsetX;
        if (orientation === 'horizontal') {
          textAnchor = 'end';
        } else {
          textAnchor = 'start';
        }
        break;
      case 'left':
        x = -offsetX;
        y = height / 2;
        if (orientation === 'horizontal') {
          textAnchor = 'end';
        } else {
          textAnchor = 'middle';
        }
        break;
    }
  } else {
    switch (position) {
      case 'top-left':
        x = offsetX;
        y = -offsetY;
        textAnchor = 'start';
        break;
      case 'top':
        x = width / 2;
        y = -offsetY;
        if (orientation === 'horizontal') {
          textAnchor = 'middle';
        } else {
          textAnchor = 'start';
        }
        break;
      case 'top-right':
        x = width - offsetX;
        y = -offsetY;
        if (orientation === 'horizontal') {
          textAnchor = 'end';
        } else {
          textAnchor = 'start';
        }
        break;
      case 'right':
        x = width + offsetX;
        if (orientation === 'horizontal') {
          textAnchor = 'start';
        } else {
          textAnchor = 'middle';
        }
        break;
      case 'bottom-right':
        x = width - offsetX;
        y = offsetY;
        textAnchor = 'end';
        break;
      case 'bottom':
        x = width / 2;
        y = offsetY;
        if (orientation === 'horizontal') {
          textAnchor = 'middle';
        } else {
          textAnchor = 'end';
        }
        break;
      case 'bottom-left':
        x = offsetX;
        y = offsetY;
        if (orientation === 'horizontal') {
          textAnchor = 'start';
        } else {
          textAnchor = 'end';
        }
        break;
      case 'left':
        x = -offsetX;
        if (orientation === 'horizontal') {
          textAnchor = 'end';
        } else {
          textAnchor = 'middle';
        }
        break;
    }
  }
  return {
    x: x,
    y: y,
    rotation: rotation,
    textAnchor: textAnchor
  };
};
var CartesianMarkersItem = function CartesianMarkersItem(_ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      axis = _ref2.axis,
      scale = _ref2.scale,
      value = _ref2.value,
      theme = _ref2.theme,
      lineStyle = _ref2.lineStyle,
      textStyle = _ref2.textStyle,
      legend = _ref2.legend,
      legendPosition = _ref2.legendPosition,
      legendOffsetX = _ref2.legendOffsetX,
      legendOffsetY = _ref2.legendOffsetY,
      legendOrientation = _ref2.legendOrientation;
  var x = 0;
  var x2 = 0;
  var y = 0;
  var y2 = 0;
  if (axis === 'y') {
    y = scale(value);
    x2 = width;
  } else {
    x = scale(value);
    y2 = height;
  }
  var legendNode = null;
  if (legend) {
    var legendProps = computeLabel({
      axis: axis,
      width: width,
      height: height,
      position: legendPosition,
      offsetX: legendOffsetX,
      offsetY: legendOffsetY,
      orientation: legendOrientation
    });
    legendNode = React__default.createElement("text", {
      transform: "translate(".concat(legendProps.x, ", ").concat(legendProps.y, ") rotate(").concat(legendProps.rotation, ")"),
      textAnchor: legendProps.textAnchor,
      alignmentBaseline: "central",
      style: textStyle
    }, legend);
  }
  return React__default.createElement("g", {
    transform: "translate(".concat(x, ", ").concat(y, ")")
  }, React__default.createElement("line", {
    x1: 0,
    x2: x2,
    y1: 0,
    y2: y2,
    stroke: theme.markers.lineColor,
    strokeWidth: theme.markers.lineStrokeWidth,
    style: lineStyle
  }), legendNode);
};
CartesianMarkersItem.propTypes = {
  width: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  axis: PropTypes.oneOf(['x', 'y']).isRequired,
  scale: PropTypes.func.isRequired,
  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
  lineStyle: PropTypes.object,
  textStyle: PropTypes.object,
  legend: PropTypes.string,
  legendPosition: PropTypes.oneOf(['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left']),
  legendOffsetX: PropTypes.number.isRequired,
  legendOffsetY: PropTypes.number.isRequired,
  legendOrientation: PropTypes.oneOf(['horizontal', 'vertical']).isRequired,
  theme: PropTypes.shape({
    markers: PropTypes.shape({
      textColor: PropTypes.string.isRequired,
      fontSize: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired
    }).isRequired
  }).isRequired
};
CartesianMarkersItem.defaultProps = {
  legendPosition: 'top-right',
  legendOffsetX: 14,
  legendOffsetY: 14,
  legendOrientation: 'horizontal'
};
var CartesianMarkersItem$1 = pure(CartesianMarkersItem);

function _extends$5() { _extends$5 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }
var CartesianMarkers = function CartesianMarkers(_ref) {
  var markers = _ref.markers,
      width = _ref.width,
      height = _ref.height,
      xScale = _ref.xScale,
      yScale = _ref.yScale,
      theme = _ref.theme;
  if (!markers || markers.length === 0) return null;
  return React__default.createElement("g", null, markers.map(function (marker, i) {
    return React__default.createElement(CartesianMarkersItem$1, _extends$5({
      key: i
    }, marker, {
      width: width,
      height: height,
      scale: marker.axis === 'y' ? yScale : xScale,
      theme: theme
    }));
  }));
};
CartesianMarkers.propTypes = {
  width: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  xScale: PropTypes.func.isRequired,
  yScale: PropTypes.func.isRequired,
  theme: PropTypes.shape({
    markers: PropTypes.shape({
      lineColor: PropTypes.string.isRequired,
      lineStrokeWidth: PropTypes.number.isRequired,
      text: PropTypes.shape({
        fill: PropTypes.string.isRequired,
        fontFamily: PropTypes.string.isRequired,
        fontSize: PropTypes.number.isRequired
      }).isRequired
    }).isRequired
  }).isRequired,
  markers: PropTypes.arrayOf(PropTypes.shape({
    axis: PropTypes.oneOf(['x', 'y']).isRequired,
    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
    lineStyle: PropTypes.object,
    textStyle: PropTypes.object
  }))
};
var CartesianMarkers$1 = pure(CartesianMarkers);

var boxAlignments = ['center', 'top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];
var alignBox = function alignBox(box, container, alignment) {
  var deltaX = container.width - box.width;
  var deltaY = container.height - box.height;
  var x = 0;
  var y = 0;
  if (alignment === 'center') {
    x = deltaX / 2;
    y = deltaY / 2;
  }
  if (alignment === 'top') {
    x = deltaX / 2;
  }
  if (alignment === 'top-right') {
    x = deltaX;
  }
  if (alignment === 'right') {
    x = deltaX;
    y = deltaY / 2;
  }
  if (alignment === 'bottom-right') {
    x = deltaX;
    y = deltaY;
  }
  if (alignment === 'bottom') {
    x = deltaX / 2;
    y = deltaY;
  }
  if (alignment === 'bottom-left') {
    y = deltaY;
  }
  if (alignment === 'left') {
    y = deltaY / 2;
  }
  return [x, y];
};

var getDistance = function getDistance(x1, y1, x2, y2) {
  var deltaX = x2 - x1;
  var deltaY = y2 - y1;
  deltaX *= deltaX;
  deltaY *= deltaY;
  return Math.sqrt(deltaX + deltaY);
};
var getAngle = function getAngle(x1, y1, x2, y2) {
  var angle = Math.atan2(y2 - y1, x2 - x1) - Math.PI / 2;
  return angle > 0 ? angle : Math.PI * 2 + angle;
};
var isCursorInRect = function isCursorInRect(x, y, width, height, cursorX, cursorY) {
  return x <= cursorX && cursorX <= x + width && y <= cursorY && cursorY <= y + height;
};
var isCursorInRing = function isCursorInRing(centerX, centerY, radius, innerRadius, cursorX, cursorY) {
  var distance = getDistance(cursorX, cursorY, centerX, centerY);
  return distance < radius && distance > innerRadius;
};
var getHoveredArc = function getHoveredArc(centerX, centerY, radius, innerRadius, arcs, cursorX, cursorY) {
  if (!isCursorInRing(centerX, centerY, radius, innerRadius, cursorX, cursorY)) return null;
  var cursorAngle = getAngle(cursorX, cursorY, centerX, centerY);
  return arcs.find(function (_ref) {
    var startAngle = _ref.startAngle,
        endAngle = _ref.endAngle;
    return cursorAngle >= startAngle && cursorAngle < endAngle;
  });
};

var getRelativeCursor = function getRelativeCursor(el, event) {
  var clientX = event.clientX,
      clientY = event.clientY;
  var bounds = el.getBoundingClientRect();
  return [clientX - bounds.left, clientY - bounds.top];
};

function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$n(target, key, source[key]); }); } return target; }
function _defineProperty$n(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var horizontalPositions$2 = ['top', 'bottom'];
var positions$1 = ['top', 'right', 'bottom', 'left'];
var renderAxisToCanvas = function renderAxisToCanvas(ctx, _ref) {
  var width = _ref.width,
      height = _ref.height,
      position = _ref.position,
      scale = _ref.scale,
      _ref$tickSize = _ref.tickSize,
      tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,
      _ref$tickPadding = _ref.tickPadding,
      tickPadding = _ref$tickPadding === void 0 ? 5 : _ref$tickPadding,
      _ref$tickRotation = _ref.tickRotation,
      tickRotation = _ref$tickRotation === void 0 ? 0 : _ref$tickRotation,
      format = _ref.format,
      theme = _ref.theme;
  var _computeAxisTicks = computeAxisTicks({
    width: width,
    height: height,
    position: position,
    scale: scale,
    tickSize: tickSize,
    tickPadding: tickPadding,
    tickRotation: tickRotation,
    engine: 'canvas'
  }),
      x = _computeAxisTicks.x,
      y = _computeAxisTicks.y,
      ticks = _computeAxisTicks.ticks,
      textAlign = _computeAxisTicks.textAlign,
      textBaseline = _computeAxisTicks.textBaseline;
  ctx.save();
  ctx.translate(x, y);
  ctx.textAlign = textAlign;
  ctx.textBaseline = textBaseline;
  ctx.font = "".concat(theme.axis.ticks.text.fontSize, "px sans-serif");
  ticks.forEach(function (tick) {
    ctx.lineWidth = theme.axis.ticks.line.strokeWidth;
    ctx.strokeStyle = theme.axis.ticks.line.stroke;
    ctx.beginPath();
    ctx.moveTo(tick.x, tick.y);
    ctx.lineTo(tick.x + tick.lineX, tick.y + tick.lineY);
    ctx.stroke();
    var value = format !== undefined ? format(tick.value) : tick.value;
    ctx.save();
    ctx.translate(tick.x + tick.textX, tick.y + tick.textY);
    ctx.rotate(degreesToRadians(tickRotation));
    ctx.fillStyle = theme.axis.ticks.text.fill;
    ctx.fillText(value, 0, 0);
    ctx.restore();
  });
  ctx.restore();
};
var renderAxesToCanvas = function renderAxesToCanvas(ctx, _ref2) {
  var xScale = _ref2.xScale,
      yScale = _ref2.yScale,
      width = _ref2.width,
      height = _ref2.height,
      top = _ref2.top,
      right = _ref2.right,
      bottom = _ref2.bottom,
      left = _ref2.left,
      theme = _ref2.theme;
  var axes = {
    top: top,
    right: right,
    bottom: bottom,
    left: left
  };
  positions$1.map(function (position) {
    if (!axes[position]) return null;
    var axis = axes[position];
    var scale = horizontalPositions$2.includes(position) ? xScale : yScale;
    renderAxisToCanvas(ctx, _objectSpread$g({}, axis, {
      width: width,
      height: height,
      position: position,
      scale: scale,
      theme: theme
    }));
  });
};
var renderGridLinesToCanvas = function renderGridLinesToCanvas(ctx, _ref3) {
  var width = _ref3.width,
      height = _ref3.height,
      scale = _ref3.scale,
      axis = _ref3.axis;
  var lines = computeGridLines({
    width: width,
    height: height,
    scale: scale,
    axis: axis
  });
  lines.forEach(function (line) {
    ctx.beginPath();
    ctx.moveTo(line.x1, line.y1);
    ctx.lineTo(line.x2, line.y2);
    ctx.stroke();
  });
};

function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$o(target, key, source[key]); }); } return target; }
function _defineProperty$o(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toConsumableArray$1(arr) { return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1(); }
function _nonIterableSpread$1() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }
function _iterableToArray$1(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }
function _arrayWithoutHoles$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }
var gradientKeys = Object.keys(gradientTypes);
var patternKeys = Object.keys(patternTypes);
var isMatchingDef = function isMatchingDef(predicate, node, dataKey) {
  if (predicate === '*') {
    return true;
  } else if (isFunction(predicate)) {
    return predicate(node);
  } else if (isPlainObject(predicate)) {
    var data = dataKey ? get(node, dataKey) : node;
    return isEqual(pick(data, Object.keys(predicate)), predicate);
  }
  return false;
};
var bindDefs = function bindDefs(defs, nodes, rules) {
  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      dataKey = _ref.dataKey,
      _ref$colorKey = _ref.colorKey,
      colorKey = _ref$colorKey === void 0 ? 'color' : _ref$colorKey,
      _ref$targetKey = _ref.targetKey,
      targetKey = _ref$targetKey === void 0 ? 'fill' : _ref$targetKey;
  var boundDefs = [];
  var generatedIds = {};
  if (defs.length && nodes.length) {
    boundDefs = _toConsumableArray$1(defs);
    nodes.forEach(function (node) {
      var _loop = function _loop(i) {
        var _rules$i = rules[i],
            id = _rules$i.id,
            match = _rules$i.match;
        if (isMatchingDef(match, node, dataKey)) {
          var def = defs.find(function (_ref2) {
            var defId = _ref2.id;
            return defId === id;
          });
          if (def) {
            if (patternKeys.includes(def.type)) {
              if (def.background === 'inherit' || def.color === 'inherit') {
                var nodeColor = get(node, colorKey);
                var background = def.background;
                var color = def.color;
                var inheritedId = id;
                if (def.background === 'inherit') {
                  inheritedId = "".concat(inheritedId, ".bg.").concat(nodeColor);
                  background = nodeColor;
                }
                if (def.color === 'inherit') {
                  inheritedId = "".concat(inheritedId, ".fg.").concat(nodeColor);
                  color = nodeColor;
                }
                set(node, targetKey, "url(#".concat(inheritedId, ")"));
                if (!generatedIds[inheritedId]) {
                  boundDefs.push(_objectSpread$h({}, def, {
                    id: inheritedId,
                    background: background,
                    color: color
                  }));
                  generatedIds[inheritedId] = 1;
                }
              } else {
                set(node, targetKey, "url(#".concat(id, ")"));
              }
            } else if (gradientKeys.includes(def.type)) {
              var allColors = def.colors.map(function (_ref3) {
                var color = _ref3.color;
                return color;
              });
              if (allColors.includes('inherit')) {
                var _nodeColor = get(node, colorKey);
                var _inheritedId = id;
                var inheritedDef = _objectSpread$h({}, def, {
                  colors: def.colors.map(function (colorStop, i) {
                    if (colorStop.color !== 'inherit') return colorStop;
                    _inheritedId = "".concat(_inheritedId, ".").concat(i, ".").concat(_nodeColor);
                    return _objectSpread$h({}, colorStop, {
                      color: colorStop.color === 'inherit' ? _nodeColor : colorStop.color
                    });
                  })
                });
                inheritedDef.id = _inheritedId;
                set(node, targetKey, "url(#".concat(_inheritedId, ")"));
                if (!generatedIds[_inheritedId]) {
                  boundDefs.push(inheritedDef);
                  generatedIds[_inheritedId] = 1;
                }
              } else {
                set(node, targetKey, "url(#".concat(id, ")"));
              }
            }
          }
          return "break";
        }
      };
      for (var i = 0; i < rules.length; i++) {
        var _ret = _loop(i);
        if (_ret === "break") break;
      }
    });
  }
  return boundDefs;
};

exports.Axes = Axes$1;
exports.Axis = Axis$1;
exports.BasicTooltip = BasicTooltip;
exports.CartesianMarkers = CartesianMarkers$1;
exports.CartesianMarkersItem = CartesianMarkersItem$1;
exports.Chip = Chip;
exports.Container = Container;
exports.Defs = Defs;
exports.DotsItem = DotsItem$1;
exports.DotsItemDefaultProps = DotsItemDefaultProps;
exports.Grid = Grid$1;
exports.LinearGradient = LinearGradient;
exports.PatternDots = PatternDots;
exports.PatternLines = PatternLines;
exports.PatternSquares = PatternSquares;
exports.ResponsiveWrapper = ResponsiveWrapper;
exports.SmartMotion = SmartMotion;
exports.SvgWrapper = SvgWrapper;
exports.TWO_PI = TWO_PI;
exports.TableTooltip = TableTooltip;
exports.absoluteAngleDegrees = absoluteAngleDegrees;
exports.absoluteAngleRadians = absoluteAngleRadians;
exports.alignBox = alignBox;
exports.areaCurvePropKeys = areaCurvePropKeys;
exports.areaCurvePropType = areaCurvePropType;
exports.axisThemePropType = axisThemePropType;
exports.bindDefs = bindDefs;
exports.blendModePropType = blendModePropType;
exports.boxAlignments = boxAlignments;
exports.closedCurvePropKeys = closedCurvePropKeys;
exports.closedCurvePropType = closedCurvePropType;
exports.colorInterpolatorIds = colorInterpolatorIds;
exports.colorInterpolators = colorInterpolators;
exports.colorMotionSpring = colorMotionSpring;
exports.colorSchemeIds = colorSchemeIds;
exports.colorSchemes = colorSchemes;
exports.computeArcBoundingBox = computeArcBoundingBox;
exports.computeAxisTicks = computeAxisTicks;
exports.computeGridLines = computeGridLines;
exports.curveFromProp = curveFromProp;
exports.curvePropKeys = curvePropKeys;
exports.curvePropMapping = curvePropMapping;
exports.curvePropType = curvePropType;
exports.defaultAnimate = defaultAnimate;
exports.defaultCategoricalColors = defaultCategoricalColors;
exports.defaultColorRange = defaultColorRange;
exports.defaultMargin = defaultMargin;
exports.defaultMotionDamping = defaultMotionDamping;
exports.defaultMotionStiffness = defaultMotionStiffness;
exports.defaultTheme = defaultTheme;
exports.defsMapping = defsMapping;
exports.defsPropTypes = defsPropTypes;
exports.degreesToRadians = degreesToRadians;
exports.dotsThemePropType = dotsThemePropType;
exports.extendDefaultTheme = extendDefaultTheme;
exports.getAccessorFor = getAccessorFor;
exports.getAccessorOrValue = getAccessorOrValue;
exports.getAngle = getAngle;
exports.getColorRange = getColorRange;
exports.getColorScale = getColorScale;
exports.getColorsGenerator = getColorsGenerator;
exports.getDistance = getDistance;
exports.getHoveredArc = getHoveredArc;
exports.getInheritedColorGenerator = getInheritedColorGenerator;
exports.getInterpolatedColor = getInterpolatedColor;
exports.getLabelGenerator = getLabelGenerator;
exports.getPolarLabelProps = getPolarLabelProps;
exports.getRelativeCursor = getRelativeCursor;
exports.gradientTypes = gradientTypes;
exports.gridThemePropType = gridThemePropType;
exports.guessQuantizeColorScale = guessQuantizeColorScale;
exports.isCursorInRect = isCursorInRect;
exports.isCursorInRing = isCursorInRing;
exports.isMatchingDef = isMatchingDef;
exports.labelsThemePropType = labelsThemePropType;
exports.legendsThemePropType = legendsThemePropType;
exports.lineCurvePropKeys = lineCurvePropKeys;
exports.lineCurvePropType = lineCurvePropType;
exports.linearGradientDef = linearGradientDef;
exports.marginPropType = marginPropType;
exports.markersThemePropType = markersThemePropType;
exports.midAngle = midAngle;
exports.motionPropTypes = motionPropTypes;
exports.nivoCategoricalColors = nivoCategoricalColors;
exports.noop = noop;
exports.patternDotsDef = patternDotsDef;
exports.patternLinesDef = patternLinesDef;
exports.patternSquaresDef = patternSquaresDef;
exports.patternTypes = patternTypes;
exports.positionFromAngle = positionFromAngle;
exports.quantizeColorScalePropType = quantizeColorScalePropType;
exports.quantizeColorScales = quantizeColorScales;
exports.quantizeColorScalesKeys = quantizeColorScalesKeys;
exports.radiansToDegrees = radiansToDegrees;
exports.renderAxesToCanvas = renderAxesToCanvas;
exports.renderAxisToCanvas = renderAxisToCanvas;
exports.renderGridLinesToCanvas = renderGridLinesToCanvas;
exports.scalePropType = scalePropType;
exports.stackOffsetFromProp = stackOffsetFromProp;
exports.stackOffsetPropKeys = stackOffsetPropKeys;
exports.stackOffsetPropMapping = stackOffsetPropMapping;
exports.stackOffsetPropType = stackOffsetPropType;
exports.stackOrderFromProp = stackOrderFromProp;
exports.stackOrderPropKeys = stackOrderPropKeys;
exports.stackOrderPropMapping = stackOrderPropMapping;
exports.stackOrderPropType = stackOrderPropType;
exports.textPropsByEngine = textPropsByEngine;
exports.themeContext = themeContext;
exports.themePropType = themePropType;
exports.tooltipContext = tooltipContext;
exports.treeMapTileFromProp = treeMapTileFromProp;
exports.treeMapTilePropKeys = treeMapTilePropKeys;
exports.treeMapTilePropMapping = treeMapTilePropMapping;
exports.treeMapTilePropType = treeMapTilePropType;
exports.useDimensions = useDimensions;
exports.usePartialTheme = usePartialTheme;
exports.useTheme = useTheme;
exports.useTooltip = useTooltip;
exports.withColors = withColors;
exports.withContainer = withContainer;
exports.withCurve = withCurve;
exports.withDimensions = withDimensions;
exports.withHierarchy = withHierarchy;
exports.withMotion = withMotion;
exports.withTheme = withTheme;
